{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\": \"AWS Support - Directory Service Troubleshooter\",\n  \"schemaVersion\": \"0.3\",\n  \"assumeRole\": \"{{ AutomationAssumeRole }}\",\n  \"parameters\": {\n    \"DirectoryId\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) The Id of the directory to troubleshoot.\",\n      \"allowedPattern\": \"^d-[a-z0-9]{10}$\",\n      \"default\": \"\"\n    },\n    \"TrustId\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The Id of the trust relationship to troubleshoot.\",\n      \"allowedPattern\": \"^$|^t-[0-9a-f]{10}$\",\n      \"default\": \"\"\n    },\n    \"RemoteDomainCidrs\": {\n      \"type\": \"StringList\",\n      \"description\": \"(Required) The CIDR(s) of the remote domain you are attempting to establish a Trust Relationship with. You can add multiple CIDRs using comma-separated values. Valid formats: 172.31.48.0/20, 192.168.1.10/32, etc.\",\n      \"allowedPattern\": \"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/(3[0-2]|[1-2][0-9]|[1-9]))$\"\n    },\n    \"RemoteDomainName\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) The FQDN of the remote domain you are attempting to establish a Trust Relationship with.\",\n      \"allowedPattern\": \"^([a-zA-Z0-9]+[\\\\.-])+([a-zA-Z0-9])+[.]?$\"\n    },\n    \"AutomationAssumeRole\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. \",\n      \"default\": \"\"\n    },\n    \"RequiredTrafficSG\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) Directory Service inbound and outbound Security Group traffic requirements. These are the default required ports. You should not modify this value.\",\n      \"default\": \"{\\\"inbound\\\":{\\\"tcp\\\":[[53,53],[88,88],[135,135],[389,389],[445,445],[464,464],[636,636],[1024,65535]],\\\"udp\\\":[[53,53],[88,88],[123,123],[138,138],[389,389],[445,445],[464,464]],\\\"icmp\\\":[[-1,-1]]},\\\"outbound\\\":{\\\"-1\\\":[[0,65535]]}}\"\n    },\n    \"RequiredTrafficACL\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) Directory Service inbound and outbound Network ACL traffic requirements. These are the default required ports. You should not modify this value.\",\n      \"default\": \"{\\\"inbound\\\":{\\\"tcp\\\":[[53,53],[88,88],[135,135],[389,389],[445,445],[464,464],[636,636],[1024,65535]],\\\"udp\\\":[[53,53],[88,88],[123,123],[138,138],[389,389],[445,445],[464,464]],\\\"icmp\\\":[[-1,-1]]},\\\"outbound\\\":{\\\"-1\\\":[[0,65535]]}}\"\n    }\n  },\n  \"outputs\": [\n    \"evaluateRemoteDomainCidr.output\",\n    \"evalDirectorySecurityGroup.output\",\n    \"evalAclEntries.output\"\n  ],\n  \"mainSteps\": [\n    {\n      \"name\": \"assertDirectoryType\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ds\",\n        \"Api\": \"DescribeDirectories\",\n        \"DirectoryIds\": [\n          \"{{ DirectoryId }}\"\n        ],\n        \"PropertySelector\": \"$.DirectoryDescriptions[0].Type\",\n        \"DesiredValues\": [\n          \"MicrosoftAD\"\n        ]\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"getDirectoryInfo\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ds\",\n        \"Api\": \"DescribeDirectories\",\n        \"DirectoryIds\": [\n          \"{{ DirectoryId }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directoryDnsIpAddrs\",\n          \"Selector\": \"$.DirectoryDescriptions[0].DnsIpAddrs\",\n          \"Type\": \"StringList\"\n        },\n        {\n          \"Name\": \"directoryVpcId\",\n          \"Selector\": \"$.DirectoryDescriptions[0].VpcSettings.VpcId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"directorySecurityGroupId\",\n          \"Selector\": \"$.DirectoryDescriptions[0].VpcSettings.SecurityGroupId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"directorySubnets\",\n          \"Selector\": \"$.DirectoryDescriptions[0].VpcSettings.SubnetIds\",\n          \"Type\": \"StringList\"\n        }\n      ],\n      \"nextStep\": \"branchOnGetDirectoryTrust\"\n    },\n    {\n      \"name\": \"branchOnGetDirectoryTrust\",\n      \"action\": \"aws:branch\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"getDirectoryTrust\",\n            \"Variable\": \"{{ TrustId }}\",\n            \"StartsWith\": \"t-\"\n          }\n        ],\n        \"Default\": \"getDirectoryConditionalForwarder\"\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"getDirectoryTrust\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ds\",\n        \"Api\": \"DescribeTrusts\",\n        \"DirectoryId\": \"{{ DirectoryId }}\",\n        \"TrustIds\": [\n          \"{{ TrustId }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directoryTrustState\",\n          \"Selector\": \"$.Trusts[0].TrustState\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"directoryTrust\",\n          \"Selector\": \"$.Trusts[0]\",\n          \"Type\": \"StringMap\"\n        }\n      ],\n      \"nextStep\": \"getDirectoryConditionalForwarder\"\n    },\n    {\n      \"name\": \"getDirectoryConditionalForwarder\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ds\",\n        \"Api\": \"DescribeConditionalForwarders\",\n        \"DirectoryId\": \"{{ DirectoryId }}\",\n        \"RemoteDomainNames\": [\n          \"{{ RemoteDomainName }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directoryForwarderDnsIpAddrs\",\n          \"Selector\": \"$.ConditionalForwarders[0].DnsIpAddrs\",\n          \"Type\": \"StringList\"\n        }\n      ],\n      \"nextStep\": \"getDirectoryIPRoutes\"\n    },\n    {\n      \"name\": \"getDirectoryIPRoutes\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ds\",\n        \"Api\": \"ListIpRoutes\",\n        \"DirectoryId\": \"{{ DirectoryId }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directoryIPRoutes\",\n          \"Selector\": \"$.IpRoutesInfo\",\n          \"Type\": \"MapList\"\n        }\n      ],\n      \"nextStep\": \"getDirectorySubnetCidrs\"\n    },\n    {\n      \"name\": \"getDirectorySubnetCidrs\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeSubnets\",\n        \"SubnetIds\": [\n          \"{{ getDirectoryInfo.directorySubnets }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directorySubnetCidrs\",\n          \"Selector\": \"$.Subnets..CidrBlock\",\n          \"Type\": \"StringList\"\n        }\n      ],\n      \"nextStep\": \"getDirectorySecurityGroup\"\n    },\n    {\n      \"name\": \"getDirectorySecurityGroup\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeSecurityGroups\",\n        \"GroupIds\": [\n          \"{{ getDirectoryInfo.directorySecurityGroupId }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directorySecurityGroups\",\n          \"Selector\": \"$.SecurityGroups\",\n          \"Type\": \"MapList\"\n        }\n      ],\n      \"nextStep\": \"getDirectoryAcl\"\n    },\n    {\n      \"name\": \"getDirectoryAcl\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeNetworkAcls\",\n        \"Filters\": [\n          {\n            \"Name\": \"association.subnet-id\",\n            \"Values\": \"{{ getDirectoryInfo.directorySubnets }}\"\n          }\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"directoryAcls\",\n          \"Selector\": \"$.NetworkAcls\",\n          \"Type\": \"MapList\"\n        }\n      ],\n      \"nextStep\": \"evaluateRemoteDomainCidr\"\n    },\n    {\n      \"name\": \"evaluateRemoteDomainCidr\",\n      \"action\": \"aws:executeScript\",\n      \"timeoutSeconds\": 45,\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"evaluateRemoteDomainCidr\",\n        \"InputPayload\": {\n          \"remoteCidrs\": \"{{ RemoteDomainCidrs }}\",\n          \"directoryIPRoutes\": \"{{ getDirectoryIPRoutes.directoryIPRoutes }}\"\n        },\n        \"Script\": \"# Handler Function\\ndef evaluateRemoteDomainCidr(events,context):\\n    from ipaddress import ip_network\\n    import re\\n\\n    err = False\\n    directoryForwarderDnsIpAddrs = []#events['directoryForwarderDnsIpAddrs']\\n    directoryIPRoutes = events['directoryIPRoutes']\\n    remoteCidrs = events['remoteCidrs']\\n\\n    # Check if all DNS entries in the Conditional Forwarder have a valid route if public\\n    # The directoryForwarderDnsIpAddrs for the RemoteDomainName\\n    for dns in directoryForwarderDnsIpAddrs:\\n        err = err or check_if_route_exist(dns,directoryIPRoutes)\\n\\n    # Check if all remote CIDR entries have a valid route if public    \\n    for cidr in remoteCidrs:\\n        err = err or check_if_route_exist(cidr,directoryIPRoutes)\\n        \\n    if err:\\n        return { 'error':err, 'output':'Error: One or more CIDR/IP requires an IP route to be reachable. See ExecutionLog' }\\n    else:\\n        return { 'error':err, 'output':'Success: No issues with required IP routes' }\\n    \\n# Checks if an IP route exists for any public (non-RFC 1918) IP addresses \\n# of the remote Active Directory. The function checks the CIDRs provided in the document input \\n# and DNS entries of the Conditional Forwarders for the RemoteDomainName in the document input\\ndef check_if_route_exist(net4, routes):\\n    from ipaddress import ip_network\\n    err = False\\n    try:\\n        net = ip_network(net4)\\n        if not net.is_private:\\n            while(len(routes)>0):\\n                if net.overlaps(ip_network(routes[0])):\\n                    print('An IP Route exists for the public DNS ', dnsIp)\\n                    break\\n                routes.pop(0)\\n            else:\\n                print('Error: No IP routes have been added for',net,'. A route must be added in order to route traffic to the remote directory.')\\n                err = True\\n        else:\\n            print('Success:',net,'does not require an IP route because is private')\\n            \\n        return err\\n        \\n    except Exception as e:\\n        print('Error: Please enter an acceptable host or network IP Address.', str(e))\\n        return True\\n\\n\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"output\",\n          \"Selector\": \"$.Payload.output\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"error\",\n          \"Selector\": \"$.Payload.err\",\n          \"Type\": \"Boolean\"\n        }\n      ],\n      \"nextStep\": \"evalDirectorySecurityGroup\"\n    },\n    {\n      \"name\": \"evalDirectorySecurityGroup\",\n      \"action\": \"aws:executeScript\",\n      \"timeoutSeconds\": 45,\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"evalDirectorySecurityGroup\",\n        \"InputPayload\": {\n          \"remoteCidrs\": \"{{ RemoteDomainCidrs }}\",\n          \"directorySecurityGroups\": \"{{ getDirectorySecurityGroup.directorySecurityGroups }}\",\n          \"requiredTraffic\": \"{{ RequiredTrafficSG }}\"\n        },\n        \"Script\": \"# Handler Function\\ndef evalDirectorySecurityGroup(events,context):\\n    import json \\n    \\n    directorySecurityGroups = events['directorySecurityGroups']\\n    remoteCidrs = events['remoteCidrs']\\n    requiredTraffic = json.loads(events['requiredTraffic'])\\n    print('RequiredTraffic',requiredTraffic)\\n\\n    #required = { \\n    #    'inbound': {\\n    #        'tcp':[[2,20],[636,636],[53,53],[1024,65535]],\\n    #        'udp':[[2,20],[53,53],[138,138]],\\n    #        'icmp':[[-1,-1]]\\n    #    },\\n    #    'outbound': { \\n    #        '-1':[[0,65535]]\\n    #   }\\n    #}\\n   \\n    err = False\\n    source = {'network-cidrs':remoteCidrs,'security-groups':[]} \\n    err = eval_security_groups_traffic(directorySecurityGroups, source, requiredTraffic)\\n    \\n    if err:\\n        return { 'error':err, 'output':'Error: Required traffic is not allowed in Security Groups. See ExecutionLog' }\\n    else:\\n        return { 'error':err, 'output':'Success: Required traffic is allowed in Security Groups' }\\n\\ndef eval_security_groups_traffic(sgs, source, traffic):\\n    from ipaddress import ip_network\\n    try:\\n        err = False\\n        for sg in sgs:\\n            for protocol, ranges in traffic.get('inbound',[]).items():\\n                for range in ranges:\\n                    allowed = False\\n                    for r in sg.get('IpPermissions', []):\\n                        if r['IpProtocol'] in (protocol,'-1'): \\n                            if (not 'FromPort' in r and not 'ToPort' in r) or (r['FromPort'] <= range[0] and r['ToPort'] >= range[1]): # \\\"Rule allows port %s\\\" % r['fromPort']\\n                                for user_id_group_pair in r.get('UserIdGroupPairs',[]):\\n                                    for group_id in source.get('security-groups', []):\\n                                        if user_id_group_pair['GroupId'] == group_id:\\n                                            allowed = True\\n                                            break\\n                                for ip_range in r['IpRanges']:\\n                                    for network_cidr in source.get('network-cidrs', []):\\n                                        if (ip_network(ip_range['CidrIp'], strict=False).overlaps(ip_network(network_cidr, strict=False))):\\n                                            allowed = True\\n                                            break\\n                    if (not allowed):\\n                        print('No inbound Security Group rule in', sg['GroupId'],'allows connectivity for',protocol.replace(\\\"-1\\\", \\\"all\\\").upper(),'in range:',range)\\n                        err = True\\n\\n            for protocol, ranges in traffic.get('outbound',[]).items():\\n                for range in ranges:\\n                    allowed = False\\n                    for r in sg.get('IpPermissionsEgress', []):\\n                        if r['IpProtocol'] in (protocol,'-1'): \\n                            if (not 'FromPort' in r and not 'ToPort' in r) or (r['FromPort'] <= range[0] and r['ToPort'] >= range[1]): # \\\"Rule allows port %s\\\" % r['fromPort']\\n                                for user_id_group_pair in r.get('UserIdGroupPairs',[]):\\n                                    for group_id in source.get('security-groups', []):\\n                                        if user_id_group_pair['GroupId'] == group_id:\\n                                            allowed = True\\n                                            break\\n                                for ip_range in r['IpRanges']:\\n                                    for network_cidr in source.get('network-cidrs', []):\\n                                        if (ip_network(ip_range['CidrIp'], strict=False).overlaps(ip_network(network_cidr, strict=False))):\\n                                            allowed = True\\n                                            break\\n                    if (not allowed):\\n                        print('No outbound Security Group rule in', sg['GroupId'],'allows connectivity for',protocol.replace(\\\"-1\\\", \\\"all\\\").upper(),'in range:',range)\\n                        err = True\\n        return err\\n\\n    except Exception as e:\\n        print('Failed to evaluate Security Groups.', str(e))\\n        return True\\n\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"output\",\n          \"Selector\": \"$.Payload.output\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"error\",\n          \"Selector\": \"$.Payload.err\",\n          \"Type\": \"Boolean\"\n        }\n      ],\n      \"nextStep\": \"evalAclEntries\"\n    },\n    {\n      \"name\": \"evalAclEntries\",\n      \"action\": \"aws:executeScript\",\n      \"timeoutSeconds\": 45,\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Runtime\": \"python3.8\",\n        \"Handler\": \"evalAclEntries\",\n        \"InputPayload\": {\n          \"remoteCidrs\": \"{{ RemoteDomainCidrs }}\",\n          \"directoryAcl\": \"{{ getDirectoryAcl.directoryAcls }}\",\n          \"requiredTraffic\": \"{{ RequiredTrafficACL }}\"\n        },\n        \"Script\": \"def evalAclEntries(events,context):\\n    from ipaddress import ip_network\\n    import json\\n    err = False\\n    directoryNetworkAcls = events['directoryAcl']\\n    remoteCidrs = events['remoteCidrs']\\n    requiredTraffic = json.loads(events['requiredTraffic'])\\n    \\n    source = {'network-cidrs':remoteCidrs,'security-groups':[]} \\n    allows = eval_acl_rules(directoryNetworkAcls, source, requiredTraffic)\\n    #print_allowed(allows)\\n    err = check_allowed(allows, requiredTraffic)\\n\\n    if err:\\n        return { 'error':err, 'output':'Error: Required traffic is not allowed in Network ACLs. See ExecutionLog' }\\n    else:\\n        return { 'error':err, 'output':'Success: Required traffic is allowed in Network ACLs' }\\n\\ndef print_allowed(allows):\\n    for nacl_id, nacl in allows.items():\\n        print('NetworkAclId', nacl_id, 'Inbound:', list(nacl[0].items()), ' <> Outbound:', list(nacl[1].items()))\\n\\ndef eval_acl_rules(rules, source, traffic): \\n    from collections import defaultdict\\n    from ipaddress import ip_network\\n\\n    in_allow = defaultdict(list)\\n    out_allow = defaultdict(list)\\n    allows = defaultdict(list)\\n    \\n    try:\\n        for nacl in rules:\\n                for r in sorted(nacl['Entries'], key=lambda k: k['RuleNumber'], reverse=True):\\n                     #print(nacl['NetworkAclId'],out_allow)\\n                     for network_cidr in source.get('network-cidrs', []):\\n                         protocol = get_std_protocol(r['Protocol'])\\n                         #print(r['RuleNumber'],protocol,r['RuleAction'],r['Egress'],r['CidrBlock'],network_cidr,ip_network(r['CidrBlock'], strict=False).overlaps(ip_network(network_cidr, strict=False)))\\n                         if (ip_network(r['CidrBlock'], strict=False).overlaps(ip_network(network_cidr, strict=False))):\\n                              if not 'PortRange' in r:\\n                                   f=0\\n                                   t=65535\\n                              else:\\n                                   f=r['PortRange']['From']\\n                                   t=r['PortRange']['To']\\n\\n                              if not r['Egress']:\\n                                   if r['RuleAction'] == 'allow':\\n                                        in_allow[protocol] = range_add([f,t],in_allow[protocol])\\n                                   else:\\n                                        in_allow[protocol] = range_diff([f,t],in_allow[protocol])\\n                              else:\\n                                   if r['RuleAction'] == 'allow':\\n\\n                                        out_allow[protocol] = range_add([f,t],out_allow[protocol])\\n                                   else:\\n                                        out_allow[protocol] = range_diff([f,t],out_allow[protocol])\\n               \\n                allows[nacl['NetworkAclId']].append(in_allow.copy())#[0]\\n                allows[nacl['NetworkAclId']].append(out_allow.copy())#[1]\\n                in_allow.clear()\\n                out_allow.clear()\\n\\n        return allows\\n    \\n    except Exception as e:\\n        print('Failed to evaluate Network ACLs.', str(e))\\n        return allows\\n\\ndef get_std_protocol(acl_protocol):\\n    # defined at https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\\n    customprotocol = {\\\"-1\\\":\\\"-1\\\",\\\"hopopt\\\":\\\"0\\\",\\\"icmp\\\":\\\"1\\\",\\\"igmp\\\":\\\"2\\\",\\\"ggp\\\":\\\"3\\\",\\\"ipv4\\\":\\\"4\\\",\\\"st\\\":\\\"5\\\",\\\"tcp\\\":\\\"6\\\",\\\"cbt\\\":\\\"7\\\",\\\"egp\\\":\\\"8\\\",\\\"igp\\\":\\\"9\\\",\\\"bbn-rcc-mon\\\":\\\"10\\\",\\\"nvp-ii\\\":\\\"11\\\",\\\"pup\\\":\\\"12\\\",\\\"argus\\\":\\\"13\\\",\\\"emcon\\\":\\\"14\\\",\\\"xnet\\\":\\\"15\\\",\\\"chaos\\\":\\\"16\\\",\\\"udp\\\":\\\"17\\\",\\\"mux\\\":\\\"18\\\",\\\"dcn-meas\\\":\\\"19\\\",\\\"hmp\\\":\\\"20\\\",\\\"prm\\\":\\\"21\\\",\\\"xns-idp\\\":\\\"22\\\",\\\"trunk-1\\\":\\\"23\\\",\\\"trunk-2\\\":\\\"24\\\",\\\"leaf-1\\\":\\\"25\\\",\\\"leaf-2\\\":\\\"26\\\",\\\"rdp\\\":\\\"27\\\",\\\"irtp\\\":\\\"28\\\",\\\"iso-tp4\\\":\\\"29\\\",\\\"netblt\\\":\\\"30\\\",\\\"mfe-nsp\\\":\\\"31\\\",\\\"merit-inp\\\":\\\"32\\\",\\\"dccp\\\":\\\"33\\\",\\\"3pc\\\":\\\"34\\\",\\\"idpr\\\":\\\"35\\\",\\\"xtp\\\":\\\"36\\\",\\\"ddp\\\":\\\"37\\\",\\\"idpr-cmtp\\\":\\\"38\\\",\\\"tp++\\\":\\\"39\\\",\\\"il\\\":\\\"40\\\",\\\"ipv6\\\":\\\"41\\\",\\\"sdrp\\\":\\\"42\\\",\\\"ipv6-route\\\":\\\"43\\\",\\\"ipv6-frag\\\":\\\"44\\\",\\\"idrp\\\":\\\"45\\\",\\\"rsvp\\\":\\\"46\\\",\\\"gre\\\":\\\"47\\\",\\\"dsr\\\":\\\"48\\\",\\\"bna\\\":\\\"49\\\",\\\"esp\\\":\\\"50\\\",\\\"ah\\\":\\\"51\\\",\\\"i-nlsp\\\":\\\"52\\\",\\\"swipe\\\":\\\"53\\\",\\\"narp\\\":\\\"54\\\",\\\"mobile\\\":\\\"55\\\",\\\"tlsp\\\":\\\"56\\\",\\\"ipv6-icmp\\\":\\\"58\\\",\\\"ipv6-nonxt\\\":\\\"59\\\",\\\"ipv6-opts\\\":\\\"60\\\",\\\"61\\\":\\\"61\\\",\\\"cftp\\\":\\\"62\\\",\\\"63\\\":\\\"63\\\",\\\"sat-expak\\\":\\\"64\\\",\\\"kryptolan\\\":\\\"65\\\",\\\"rvd\\\":\\\"66\\\",\\\"ippc\\\":\\\"67\\\",\\\"68\\\":\\\"68\\\",\\\"sat-mon\\\":\\\"69\\\",\\\"visa\\\":\\\"70\\\",\\\"ipcv\\\":\\\"71\\\",\\\"cpnx\\\":\\\"72\\\",\\\"cphb\\\":\\\"73\\\",\\\"wsn\\\":\\\"74\\\",\\\"pvp\\\":\\\"75\\\",\\\"br-sat-mon\\\":\\\"76\\\",\\\"sun-nd\\\":\\\"77\\\",\\\"wb-mon\\\":\\\"78\\\",\\\"wb-expak\\\":\\\"79\\\",\\\"iso-ip\\\":\\\"80\\\",\\\"vmtp\\\":\\\"81\\\",\\\"secure-vmtp\\\":\\\"82\\\",\\\"vines\\\":\\\"83\\\",\\\"ttp\\\":\\\"84\\\",\\\"nsfnet-igp\\\":\\\"85\\\",\\\"dgp\\\":\\\"86\\\",\\\"tcf\\\":\\\"87\\\",\\\"eigrp\\\":\\\"88\\\",\\\"ospfigp\\\":\\\"89\\\",\\\"sprite-rpc\\\":\\\"90\\\",\\\"larp\\\":\\\"91\\\",\\\"mtp\\\":\\\"92\\\",\\\"ax.25\\\":\\\"93\\\",\\\"ipip\\\":\\\"94\\\",\\\"micp\\\":\\\"95\\\",\\\"scc-sp\\\":\\\"96\\\",\\\"etherip\\\":\\\"97\\\",\\\"encap\\\":\\\"98\\\",\\\"99\\\":\\\"99\\\",\\\"gmtp\\\":\\\"100\\\",\\\"ifmp\\\":\\\"101\\\",\\\"pnni\\\":\\\"102\\\",\\\"pim\\\":\\\"103\\\",\\\"aris\\\":\\\"104\\\",\\\"scps\\\":\\\"105\\\",\\\"qnx\\\":\\\"106\\\",\\\"a/n\\\":\\\"107\\\",\\\"ipcomp\\\":\\\"108\\\",\\\"snp\\\":\\\"109\\\",\\\"compaq-peer\\\":\\\"110\\\",\\\"ipx-in-ip\\\":\\\"111\\\",\\\"vrrp\\\":\\\"112\\\",\\\"pgm\\\":\\\"113\\\",\\\"114\\\":\\\"114\\\",\\\"l2tp\\\":\\\"115\\\",\\\"dd\\\":\\\"116\\\",\\\"iatp\\\":\\\"117\\\",\\\"stp\\\":\\\"118\\\",\\\"srp\\\":\\\"119\\\",\\\"uti\\\":\\\"120\\\",\\\"smp\\\":\\\"121\\\",\\\"sm\\\":\\\"122\\\",\\\"ptp\\\":\\\"123\\\",\\\"isis-over-ipv4\\\":\\\"124\\\",\\\"fire\\\":\\\"125\\\",\\\"crtp\\\":\\\"126\\\",\\\"crudp\\\":\\\"127\\\",\\\"sscopmce\\\":\\\"128\\\",\\\"iplt\\\":\\\"129\\\",\\\"sps\\\":\\\"130\\\",\\\"pipe\\\":\\\"131\\\",\\\"sctp\\\":\\\"132\\\",\\\"fc\\\":\\\"133\\\",\\\"rsvp-e2e-ignore\\\":\\\"134\\\",\\\"mobility-header\\\":\\\"135\\\",\\\"udplite\\\":\\\"136\\\",\\\"mpls-in-ip\\\":\\\"137\\\",\\\"manet\\\":\\\"138\\\",\\\"hip\\\":\\\"139\\\",\\\"shim6\\\":\\\"140\\\",\\\"wesp\\\":\\\"141\\\",\\\"rohc\\\":\\\"142\\\",\\\"253\\\":\\\"253\\\",\\\"254\\\":\\\"254\\\"}\\n    inv_map = {v: k for k, v in customprotocol.items()}\\n    return inv_map.get(acl_protocol)\\n\\ndef range_add(new,interv):\\n    interv.append(new)\\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\\n    interv.sort()\\n    res=[]\\n    while(len(interv)>0):\\n        if len(interv)==1:\\n            res.append(interv[0])\\n            interv.pop(0)\\n            continue\\n        if interv[0][1]>=interv[1][0]:\\n            tmp=[interv[0][0],max(interv[0][1],interv[1][1])]\\n            interv[0]=tmp\\n            interv.pop(1)\\n            continue\\n        res.append(interv[0])\\n        interv.pop(0)\\n    return res\\n\\ndef range_diff(new,interv):\\n    interv = range_add([],interv)\\n    if len(new)==0:\\n        new = [0,0]\\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\\n    interv.sort()\\n    res=[]\\n    for t in interv:\\n        s1, e1 = t\\n        s2, e2 = new\\n        s = sorted((s1, s2, e1, e2))\\n        if s[0] == s1 and s[0] != s[1]:\\n            v = s[1] if e1 < s2 else s[1]-1 \\n            res.append([s[0],v])\\n        if s[3] == e1 and s[2] != s[3]:\\n            v = s[2] if e2 < s1 else s[2]+1\\n            res.append([v,s[3]])\\n    if len(res)==0:\\n        res = [[0,0]]\\n    return res\\n\\ndef check_allowed(allows, traffic):\\n    err = False\\n    for nacl_id, nacl in allows.items():\\n        for protocol, ranges in traffic.get('inbound',[]).items():\\n            for range in ranges:\\n                allowed = False\\n                for r in nacl[0].get('-1', []):\\n                    if r[0] <= range[0] and r[1] >= range[1]:\\n                        allowed = True\\n                        break\\n                for r in nacl[0].get(protocol, []):\\n                    if r[0] <= range[0] and r[1] >= range[1]:\\n                        allowed = True\\n                        break\\n            if (not allowed):\\n                print('Error: No inbound ACL rule in',nacl_id,'allows connectivity for',protocol.replace(\\\"-1\\\", \\\"all\\\").upper(),'in range:',range)\\n                err = True\\n            else:\\n                break\\n\\n        for protocol, ranges in traffic.get('outbound',[]).items():\\n            for range in ranges:\\n                allowed = False\\n                for r in nacl[1].get('-1', []):\\n                    if r[0] <= range[0] and r[1] >= range[1]:\\n                        allowed = True\\n                        break\\n                for r in nacl[1].get(protocol, []):\\n                    if r[0] <= range[0] and r[1] >= range[1]:\\n                        allowed = True\\n                        break\\n            if (not allowed):\\n                print('Error: No outbound ACL rule in',nacl_id,'allows connectivity for',protocol.replace(\\\"-1\\\", \\\"all\\\").upper(),'in range:',range)\\n                err = True\\n            else:\\n                break\\n            \\n    return err\\n\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"output\",\n          \"Selector\": \"$.Payload.output\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"error\",\n          \"Selector\": \"$.Payload.err\",\n          \"Type\": \"Boolean\"\n        }\n      ],\n      \"isEnd\": true\n    }\n  ]\n}",
  "CreatedDate": "2022-07-08T15:00:14.522Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "2",
  "Name": "AWSSupport-TroubleshootDirectoryTrust",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "81538ce2-f537-4b9e-81b7-56b974fa5160",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 28010,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-09-23T07:31:32.4209606+00:00"
}
