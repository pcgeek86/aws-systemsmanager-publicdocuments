{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\" : \"## Id\\nAWSResilienceHub-ScaleDownDocumentDBClusterSOP_2020-09-21\\n\\n## Intent\\nScale down Amazon Document DB cluster.\\n\\n## Type\\nSOP\\n\\n## Risk\\nHigh\\n\\n## Requirements\\n  * An Amazon Document DB cluster in \\\"available\\\" state with at least 3 DB instances in \\\"available\\\" state.\\n\\n## Permissions required for AutomationAssumeRole\\n  * rds:CreateDBInstance\\n  * rds:DeleteDBInstance\\n  * rds:DescribeDBClusters\\n  * rds:DescribeDBInstances\\n\\n## Cancellation behavior\\nFail\\n\\n## Inputs\\n### (Required) AutomationAssumeRole\\n  * type: String\\n  * description: ARN of the IAM role with permissions listed above.\\n\\n### (Required) DBClusterIdentifier\\n  * type: String\\n  * description: Amazon Document DB cluster identifier.\\n  * allowedPattern: \\\"[a-zA-Z0-9_.-]+\\\"\\n\\n### (Optional) NumberOfInstancesToDelete\\n* type: Integer\\n* description: The number of DB instances to delete. Ignored if at least one DBInstancesIdentifiersToDelete specified.\\n* default: 1\\n\\n### (Optional) DBInstancesIdentifiersToDelete\\n  * type: StringList\\n  * description: The list of identifiers of instances to be deleted.\\n  * default: []\\n\\n## Details\\nThe cluster after modification should satisfy the condition: 1 Primary + 1 Replica instances are available.\\nNote, that either 'NumberOfInstancesToDelete' or 'DBInstancesIdentifiersToDelete' should be provided.\\n\\n## Steps executed in normal flow\\n  * RecordStartTime\\n  * VerifyDBClusterAvailableStatusBeforeModification\\n  * GetDbClusterMembers\\n  * ValidateClusterMembersAmount\\n  * GetDBInstancesToDelete\\n  * ScaleDownDocDbCLuster\\n  * WaitForInstancesAvailableStatus\\n  * OutputRecoveryTime\\n\\n## Outputs\\n### OutputRecoveryTime.RecoveryTime\\n  * type: String\\n  * description: overall recovery time for scaling up Amazon Document DB cluster.\",\n  \"schemaVersion\" : \"0.3\",\n  \"assumeRole\" : \"{{ AutomationAssumeRole }}\",\n  \"outputs\" : [ \"OutputRecoveryTime.RecoveryTime\" ],\n  \"parameters\" : {\n    \"DBClusterIdentifier\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) Amazon Document DB cluster identifier.\",\n      \"allowedPattern\" : \"[a-zA-Z0-9_.-]+\"\n    },\n    \"NumberOfDBInstancesToDelete\" : {\n      \"type\" : \"Integer\",\n      \"description\" : \"(Optional) The number of DB instances to delete. Ignored if at least one DBInstancesIdentifiersToDelete specified.\",\n      \"default\" : 1\n    },\n    \"DBInstancesIdentifiersToDelete\" : {\n      \"type\" : \"StringList\",\n      \"description\" : \"(Optional) The list of identifiers of instances to be deleted.\",\n      \"default\" : [ ]\n    },\n    \"AutomationAssumeRole\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) The ARN of the role that allows Automation to perform the actions on your behalf.\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"RecordStartTime\",\n    \"description\" : \"Start recording execution time\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"StartTime\",\n      \"Selector\" : \"$.Payload\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"start_time\",\n      \"Script\" : \"import boto3\\nimport logging\\nfrom datetime import datetime, timezone\\nimport time\\n\\nfrom botocore.exceptions import ClientError\\nfrom dateutil import parser\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\n\\n\\ndef start_time(events, context):\\n    return datetime.now(timezone.utc).isoformat()\"\n    }\n  }, {\n    \"name\" : \"VerifyDBClusterAvailableStatusBeforeModification\",\n    \"description\" : \"On this step check, if the cluster is in \\\"available\\\" state.\",\n    \"action\" : \"aws:assertAwsResourceProperty\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Service\" : \"docdb\",\n      \"Api\" : \"DescribeDBClusters\",\n      \"DBClusterIdentifier\" : \"{{ DBClusterIdentifier }}\",\n      \"PropertySelector\" : \"$.DBClusters[0].Status\",\n      \"DesiredValues\" : [ \"available\" ]\n    }\n  }, {\n    \"name\" : \"GetDbClusterMembers\",\n    \"description\" : \"On this step retrieve DBClusterMembers.\",\n    \"action\" : \"aws:executeAwsApi\",\n    \"outputs\" : [ {\n      \"Name\" : \"DBClusterMembers\",\n      \"Selector\" : \"$.DBClusters[0].DBClusterMembers\",\n      \"Type\" : \"MapList\"\n    } ],\n    \"inputs\" : {\n      \"Service\" : \"docdb\",\n      \"Api\" : \"DescribeDBClusters\",\n      \"Filters\" : [ {\n        \"Name\" : \"db-cluster-id\",\n        \"Values\" : [ \"{{ DBClusterIdentifier }}\" ]\n      } ]\n    }\n  }, {\n    \"name\" : \"ValidateClusterMembersAmount\",\n    \"description\" : \"On this step validate that cluster contains at least 3 memebers.\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"validate_cluster_members_amount\",\n      \"Script\" : \"import logging\\nimport random\\nimport time\\nimport uuid\\nfrom concurrent.futures import ThreadPoolExecutor\\nfrom datetime import datetime\\nfrom operator import itemgetter\\nfrom typing import List\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\nif len(logging.getLogger().handlers) > 0:\\n    # The Lambda environment pre-configures a handler logging to stderr. If a handler is already configured,\\n    # `.basicConfig` does not execute. Thus we set the level directly.\\n    logging.getLogger().setLevel(logging.INFO)\\nelse:\\n    logging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\n\\n\\ndef check_required_params(required_params, events):\\n    \\\"\\\"\\\"\\n    Check for required parameters in events.\\n    \\\"\\\"\\\"\\n    for key in required_params:\\n        if not events.get(key):\\n            raise KeyError(f'Requires {key} in events')\\n\\n\\n\\ndef validate_cluster_members_amount(events, context):\\n    \\\"\\\"\\\"\\n    Ensure 2 instances before scaling down the cluster.\\n    These 2 instances will satisfy the condition 1 Primary + 1 Replica.\\n    \\\"\\\"\\\"\\n    required_params = [\\n        'DBClusterMembers'\\n    ]\\n    check_required_params(required_params, events)\\n\\n    if len(events['DBClusterMembers']) <= 2:\\n        raise AssertionError('The amount of DBClusterMembers should be greater than 2 to perform scaling down.')\",\n      \"InputPayload\" : {\n        \"DBClusterMembers\" : \"{{ GetDbClusterMembers.DBClusterMembers }}\"\n      }\n    }\n  }, {\n    \"name\" : \"GetDBInstancesToDelete\",\n    \"description\" : \"On this step define the instances to delete according to the input parameters. Consider that the cluster should have 1 Primary and 1 Replica after the follow-up modification.\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"outputs\" : [ {\n      \"Name\" : \"DBInstancesIdentifiersToDelete\",\n      \"Selector\" : \"$.Payload.DBInstancesIdentifiersToDelete\",\n      \"Type\" : \"StringList\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"get_instances_to_delete\",\n      \"Script\" : \"import logging\\nimport random\\nimport time\\nimport uuid\\nfrom concurrent.futures import ThreadPoolExecutor\\nfrom datetime import datetime\\nfrom operator import itemgetter\\nfrom typing import List\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\nif len(logging.getLogger().handlers) > 0:\\n    # The Lambda environment pre-configures a handler logging to stderr. If a handler is already configured,\\n    # `.basicConfig` does not execute. Thus we set the level directly.\\n    logging.getLogger().setLevel(logging.INFO)\\nelse:\\n    logging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\n\\n\\ndef check_required_params(required_params, events):\\n    \\\"\\\"\\\"\\n    Check for required parameters in events.\\n    \\\"\\\"\\\"\\n    for key in required_params:\\n        if not events.get(key):\\n            raise KeyError(f'Requires {key} in events')\\n\\n\\n\\ndef get_instances_to_delete_by_number(number, cluster_members):\\n    \\\"\\\"\\\"\\n    Get list of random instances identifiers from cluster replicas members.\\n    Ensure 1 Primary + 1 Replica remain after following deletion.\\n    \\\"\\\"\\\"\\n    cluster_replicas_identifiers = []\\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n    docdb = boto3.client('docdb', config=config)\\n    for member in cluster_members:\\n        db_instance_identifer = member['DBInstanceIdentifier']\\n        response = docdb.describe_db_instances(DBInstanceIdentifier=db_instance_identifer)\\n        if not member['IsClusterWriter'] and response['DBInstances'][0]['DBInstanceStatus'] == 'available':\\n            cluster_replicas_identifiers.append(db_instance_identifer)\\n\\n    cluster_members_amount = len(cluster_members)\\n    if cluster_members_amount - 2 < number:\\n        raise ValueError(f'Impossible to delete {number} instances. '\\n                         f'Max allowed for removal amount is {cluster_members_amount - 2}.')\\n    return random.sample(cluster_replicas_identifiers, number)\\n\\n\\n\\ndef get_instances_to_delete_by_ids(ids, cluster_members):\\n    \\\"\\\"\\\"\\n    Get list of instances identifiers to delete. Ensure 1 Primary + 1 Replica remain after following deletion.\\n    \\\"\\\"\\\"\\n    cluster_writer_identifier = [\\n        member['DBInstanceIdentifier'] for member in cluster_members if member['IsClusterWriter']\\n    ][0]\\n    if cluster_writer_identifier in ids:\\n        raise ValueError(f'DBInstancesIdentifiersToDelete contains Primary identifier {cluster_writer_identifier}.')\\n\\n    cluster_replicas_identifiers = [\\n        member['DBInstanceIdentifier'] for member in cluster_members if not member['IsClusterWriter']\\n    ]\\n    # at least 1 item should remain in (cluster_replicas_identifiers - ids)\\n    difference = [i for i in cluster_replicas_identifiers if i not in ids]\\n    if not difference:\\n        raise AssertionError(f'The condition `1 Primary + 1 Replica` is not satisfied if we remove instances: {ids}.')\\n    if len(difference) == len(cluster_replicas_identifiers):\\n        raise ValueError('DBInstancesIdentifiersToDelete does not contain identifiers belonging to cluster.')\\n\\n    return ids\\n\\n\\n\\ndef get_instances_to_delete(events, context):\\n    \\\"\\\"\\\"\\n    Get list of instances to delete, considering 1 condition: cluster should have 1 Primary and at least 1 Replica\\n    instance after following deletion.\\n    \\\"\\\"\\\"\\n    required_params = [\\n        'DBClusterMembers'\\n    ]\\n    check_required_params(required_params, events)\\n\\n    if not events.get('DBInstancesIdentifiersToDelete'):\\n        logging.info('Parameter \\\"DBInstancesIdentifiersToDelete\\\" will be ignored')\\n        check_required_params(['NumberOfDBInstancesToDelete'], events)\\n        return {\\n            'DBInstancesIdentifiersToDelete': get_instances_to_delete_by_number(events['NumberOfDBInstancesToDelete'],\\n                                                                                events['DBClusterMembers'])}\\n    else:\\n        logging.info('Parameter \\\"NumberOfDBInstancesToDelete\\\" will be ignored')\\n        return {\\n            'DBInstancesIdentifiersToDelete': get_instances_to_delete_by_ids(events['DBInstancesIdentifiersToDelete'],\\n                                                                             events['DBClusterMembers'])}\",\n      \"InputPayload\" : {\n        \"DBClusterMembers\" : \"{{ GetDbClusterMembers.DBClusterMembers }}\",\n        \"NumberOfDBInstancesToDelete\" : \"{{ NumberOfDBInstancesToDelete }}\",\n        \"DBInstancesIdentifiersToDelete\" : \"{{ DBInstancesIdentifiersToDelete }}\"\n      }\n    }\n  }, {\n    \"name\" : \"ScaleDownDocDbCLuster\",\n    \"description\" : \"On this step delete instances by ids provided in the previous step.\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"scale_down_cluster\",\n      \"Script\" : \"import logging\\nimport random\\nimport time\\nimport uuid\\nfrom concurrent.futures import ThreadPoolExecutor\\nfrom datetime import datetime\\nfrom operator import itemgetter\\nfrom typing import List\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\nif len(logging.getLogger().handlers) > 0:\\n    # The Lambda environment pre-configures a handler logging to stderr. If a handler is already configured,\\n    # `.basicConfig` does not execute. Thus we set the level directly.\\n    logging.getLogger().setLevel(logging.INFO)\\nelse:\\n    logging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\n\\n\\ndef check_required_params(required_params, events):\\n    \\\"\\\"\\\"\\n    Check for required parameters in events.\\n    \\\"\\\"\\\"\\n    for key in required_params:\\n        if not events.get(key):\\n            raise KeyError(f'Requires {key} in events')\\n\\n\\n\\ndef scale_down_cluster(events, context):\\n    \\\"\\\"\\\"\\n    Delete instances from the cluster.\\n    \\\"\\\"\\\"\\n    required_params = [\\n        'DBInstancesIdentifiersToDelete'\\n    ]\\n    check_required_params(required_params, events)\\n\\n    docdb = boto3.client('docdb')\\n    for identifier in events['DBInstancesIdentifiersToDelete']:\\n        docdb.delete_db_instance(DBInstanceIdentifier=identifier)\",\n      \"InputPayload\" : {\n        \"DBInstancesIdentifiersToDelete\" : \"{{ GetDBInstancesToDelete.DBInstancesIdentifiersToDelete }}\"\n      }\n    }\n  }, {\n    \"name\" : \"WaitForInstancesAvailableStatus\",\n    \"description\" : \"On this step wait for instances are in \\\"available\\\" state.\",\n    \"action\" : \"aws:waitForAwsResourceProperty\",\n    \"maxAttempts\" : 1,\n    \"timeoutSeconds\" : 900,\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Service\" : \"docdb\",\n      \"Api\" : \"DescribeDBInstances\",\n      \"Filters\" : [ {\n        \"Name\" : \"db-cluster-id\",\n        \"Values\" : [ \"{{ DBClusterIdentifier }}\" ]\n      } ],\n      \"PropertySelector\" : \"$.DBInstances..DBInstanceStatus\",\n      \"DesiredValues\" : [ \"available\" ]\n    }\n  }, {\n    \"name\" : \"OutputRecoveryTime\",\n    \"description\" : \"Calculate execution time\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"RecoveryTime\",\n      \"Selector\" : \"$.Payload\",\n      \"Type\" : \"Integer\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"recovery_time\",\n      \"Script\" : \"import boto3\\nimport logging\\nfrom datetime import datetime, timezone\\nimport time\\n\\nfrom botocore.exceptions import ClientError\\nfrom dateutil import parser\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\n\\n\\ndef recovery_time(events, context):\\n    return (datetime.now(timezone.utc) - parser.parse(events['StartTime'])).seconds\",\n      \"InputPayload\" : {\n        \"StartTime\" : \"{{ RecordStartTime.StartTime }}\"\n      }\n    },\n    \"isEnd\" : true\n  } ]\n}",
  "CreatedDate": "2021-11-05T22:27:03.384Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "1",
  "Name": "AWSResilienceHub-ScaleDownDocumentDBClusterSOP_2020-09-21",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "0c55e7f8-2c5a-44e3-8845-95408f483502",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 15560,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-03-23T07:12:25.7862602+00:00"
}
