{
  "AttachmentsContent": [],
  "Content": "{\n  \"schemaVersion\" : \"0.3\",\n  \"description\" : \"## Name\\n  AWS-SetupJupyter\\n\\n## Intent\\n  This document configures Jupyter notebook on the targeted Amazon Linux instances according to AWS recommendations. \\n  For more info refer to: https://docs.aws.amazon.com/dlami/latest/devguide/setup-jupyter-config.html\\n\\n## Notes\\n  * A role with enough permissions should be provided for the document to be able to start or stop the configuration recording (otherwise the document will run with the caller identity).\\n  * Targeted instances must be managed by System Manager.\\n  * The operating system of the instance or AMI must be linux as jupyter is not available for the other platforms.\\n  * The instance must be running to be able to execute the document.\\n  * The ssm parameter that saves the password needed to secure jupyter server must be valid.\\n\\n## Permissions required for AutomationAssumeRole\\n  * cloudformation:CreateStack.\\n  * cloudformation:DescribeStacks.\\n  * cloudformation:DeleteStack.\\n  * ec2:RunInstances.\\n  * ec2:DescribeInstances.\\n  * ec2:DescribeKeyPairs.\\n  * iam:GetRole.\\n  * iam:PassRole.\\n  * iam:DetachRolePolicy.\\n  * iam:DeleteRolePolicy.\\n  * iam:CreateRole.\\n  * iam:DeleteRole.\\n  * iam:AttachRolePolicy.\\n  * iam:PutRolePolicy.\\n  * lambda:CreateFunction.\\n  * lambda:InvokeFunction.\\n  * lambda:GetFunction.\\n  * lambda:DeleteFunction.\\n  * ssm:SendCommand.\\n  * ssm:GetAutomationExecution.\\n  * ssm:StartAutomationExecution.\\n  * ssm:GetParameter.\\n  * ssm:GetCommandInvocation.\",\n  \"assumeRole\" : \"{{ AutomationAssumeRole }}\",\n  \"parameters\" : {\n    \"AmiId\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) AMI id to use for launching the instance.\",\n      \"default\" : \"\",\n      \"allowedPattern\" : \"^$|(ami-[0-9a-f]{8,17}){0,1}\"\n    },\n    \"InstanceId\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Instance Id\",\n      \"default\" : \"\",\n      \"allowedPattern\" : \"^$|i-[a-z0-9]{8,17}$\"\n    },\n    \"VpcId\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) New instance will be deployed into this vpc or in the default vpc if not specified.\",\n      \"default\" : \"Default\",\n      \"allowedPattern\" : \"[-_a-zA-Z0-9]*\"\n    },\n    \"SubnetId\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) New instance will be deployed into this subnet or in the default subnet if not specified.\",\n      \"default\" : \"Default\",\n      \"allowedPattern\" : \"[-_a-zA-Z0-9]*\"\n    },\n    \"RoleName\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Role Name to create.\",\n      \"default\" : \"SSMManagedLinuxInstanceProfileRole\",\n      \"allowedPattern\" : \"[-_a-zA-Z0-9]*\"\n    },\n    \"SecGroupName\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Security Group Name to create.\",\n      \"default\" : \"SSMSecurityGroupForLinuxInstances\",\n      \"allowedPattern\" : \"^\\\\S|\\\\S[A-Za-z0-9_-]*$\"\n    },\n    \"InstanceType\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Type of instance to launch. Default is t3.medium.\",\n      \"default\" : \"t3.medium\",\n      \"allowedPattern\" : \"^[a-z]\\\\d.*\"\n    },\n    \"KeyPairName\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Key pair to use when creating instance.\",\n      \"default\" : \"\",\n      \"allowedPattern\" : \"^[A-Za-z0-9_-]*$\"\n    },\n    \"RemoteAccessCidr\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Replaced by make.\",\n      \"default\" : \"0.0.0.0/0\",\n      \"allowedPattern\" : \"(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})/(\\\\d{1,2})|^pl-[a-z0-9]{8,15}$\"\n    },\n    \"AutomationAssumeRole\" : {\n      \"type\" : \"AWS::IAM::Role::Arn\",\n      \"description\" : \"(Optional) The ARN of the role that allows Automation to perform the actions on your behalf\",\n      \"default\" : \"\",\n      \"allowedPattern\" : \"^$|arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role\\\\/?[a-zA-Z_0-9+=,.@\\\\-_\\\\/]+\"\n    },\n    \"JupyterPasswordSSMKey\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) The name of an encrypted SSM Parameter containing the password to secure Jupyter.\",\n      \"allowedPattern\" : \"^[a-zA-Z0-9_.-/]*$\"\n    },\n    \"StackName\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) The stack where the instance will be created\",\n      \"default\" : \"CreateManagedInstanceStack\",\n      \"allowedPattern\" : \"[-_a-zA-Z0-9]*\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"SetupJupyter\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"isCritical\" : true,\n    \"timeoutSeconds\" : 300,\n    \"description\" : \"## SetupJupyterScriptExecution\\nConfigures Jupyter notebook on the targeted Amazon Linux instances according to AWS recommendations.\\n\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"setup_jupyter\",\n      \"InputPayload\" : {\n        \"InstanceId\" : \"{{InstanceId}}\",\n        \"JupyterPasswordSSMKey\" : \"{{JupyterPasswordSSMKey}}\",\n        \"VpcId\" : \"{{VpcId}}\",\n        \"AmiId\" : \"{{AmiId}}\",\n        \"SubnetId\" : \"{{SubnetId}}\",\n        \"RoleName\" : \"{{RoleName}}\",\n        \"InstanceType\" : \"{{InstanceType}}\",\n        \"SecGroupName\" : \"{{SecGroupName}}\",\n        \"KeyPairName\" : \"{{KeyPairName}}\",\n        \"RemoteAccessCidr\" : \"{{RemoteAccessCidr}}\",\n        \"StackName\" : \"{{StackName}}\"\n      },\n      \"Script\" : \"import json\\nimport boto3\\nimport time\\n\\nssm_client = boto3.client('ssm')\\nec2_client = boto3.client('ec2')\\n\\n\\ndef setup_jupyter(event, context):\\n    instance_id = event[\\\"InstanceId\\\"]\\n    ami_id = event[\\\"AmiId\\\"]\\n    key_pair = event[\\\"KeyPairName\\\"]\\n    jupyter_password_key_name = event[\\\"JupyterPasswordSSMKey\\\"]\\n    stack_name = event[\\\"StackName\\\"] \\n\\n    validateInput(instance_id, ami_id, key_pair)\\n\\n    # get jupyter password from ssm parameter store\\n    jupyter_password = get_jupyter_password_from_ssm_parameter_store(jupyter_password_key_name)\\n\\n    # check if the Ami id is provided, create a new instance \\n    if ami_id != \\\"\\\":\\n      execution_id = ssm_client.start_automation_execution(\\n        DocumentName='AWS-CreateManagedLinuxInstance',\\n        Parameters={\\n          'AmiId': [ami_id],\\n          'KeyPairName' : [key_pair],\\n          'VpcId': [event['VpcId']],\\n          'SubnetId': [event['SubnetId']],\\n          'RoleName': [event['RoleName']],\\n          'InstanceType': [event['InstanceType']],\\n          'GroupName': [event['SecGroupName']],\\n          'RemoteAccessCidr': [event['RemoteAccessCidr']],\\n          'StackName': [stack_name]\\n          },\\n      )[\\\"AutomationExecutionId\\\"]\\n\\n\\n      if automation_execution_status(execution_id) == 'Success':\\n          instance_id = ec2_client.describe_instances(\\n            Filters=[{'Name': 'tag:aws:cloudformation:stack-name', 'Values': [stack_name]}])[\\\"Reservations\\\"][0][\\\"Instances\\\"][0][\\\"InstanceId\\\"]\\n      else:\\n          raise Exception('Error creating instance given the input parameters')\\n\\n    # configure jupyter\\n    status = configure_password_and_certificate(instance_id, jupyter_password)\\n    if status == 'Success':\\n      return {'output': json.dumps({'status': 'Jupyter Successfully configured'})}\\n    else:\\n      raise Exception('Failed to configure Jupyter. Jupyter must be installed.')\\n\\ndef validateInput(instance_id, ami_id, key_pair):\\n    # check whether instance id or AMI id is provided \\n    if instance_id == \\\"\\\" and ami_id == \\\"\\\":\\n      raise Exception('instance id or Ami id should be provided')\\n    if instance_id != \\\"\\\" and ami_id != \\\"\\\":\\n      raise Exception('instance id or Ami id should be provided not both of them')\\n    if ami_id != \\\"\\\" and key_pair == \\\"\\\":\\n      raise Exception('Key pair must be present if the ami id is present')\\n    if ami_id != \\\"\\\" and key_pair != \\\"\\\":\\n      response = ec2_client.describe_key_pairs(\\n        Filters=[\\n          {\\n              'Name': 'key-name',\\n              'Values': [key_pair]\\n          },\\n        ],\\n      )[\\\"KeyPairs\\\"]\\n      if len(response) == 0:\\n        raise Exception(\\\"You must provide a valid key pair name\\\")\\n\\ndef configure_password_and_certificate(instance_id, jupyter_password):\\n    response = ssm_client.send_command(\\n      InstanceIds=[instance_id],\\n      DocumentName=\\\"AWS-RunShellScript\\\",\\n      TimeoutSeconds=500,\\n      Parameters={'commands': ['if ! jupyter notebook --version;then', 'exit 1', 'fi', 'yes {} | jupyter notebook password'.format(jupyter_password), \\n      'cd ~', 'mkdir ssl', 'cd ssl', 'yes jp | openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout mykey.key -out mycert.pem']}\\n    )\\n    command_id = response['Command']['CommandId']\\n    status, status_details = get_command_status_with_wait(instance_id, command_id)\\n\\n    return status_details\\n\\ndef get_jupyter_password_from_ssm_parameter_store(jupyter_password_key_name):\\n    try:\\n      response = ssm_client.get_parameter(\\n        Name=jupyter_password_key_name,\\n        WithDecryption=True\\n      ) \\n    except ssm_client.exceptions.ParameterNotFound as e:\\n      raise Exception('Jupyter Password not found')\\n    return response[\\\"Parameter\\\"][\\\"Value\\\"]\\n\\ndef automation_execution_status(execution_id, block_on_waiting=True, status_callback=None):\\n    \\\"\\\"\\\"Return execution status, waiting for completion if in progress.\\\"\\\"\\\"\\n    statuses = ('Pending', 'InProgress', 'Waiting')\\n    if not block_on_waiting:\\n        statuses = PENDING_AUTOMATION_STATUS\\n\\n    while True:\\n        current_status = ssm_client.get_automation_execution(\\n            AutomationExecutionId=execution_id)['AutomationExecution']['AutomationExecutionStatus']\\n        if status_callback is not None:\\n            status_callback({\\\"status\\\": current_status})\\n\\n        if current_status not in statuses:\\n            return current_status\\n        time.sleep(30)\\n\\ndef get_command_status_with_wait(instance_id, command_id):\\n    WAITING_STATUS = ['Pending', 'InProgress', 'Delayed']\\n    MAX_RETRIALS_NUM = 3\\n    retries = 0         \\n    time.sleep(2)\\n    response = ssm_client.get_command_invocation(\\n        CommandId=command_id,\\n        InstanceId=instance_id\\n    )\\n    status = response[\\\"Status\\\"]\\n    details = response[\\\"StatusDetails\\\"]\\n\\n    if status in WAITING_STATUS and retries < MAX_RETRIALS_NUM:\\n        retries += 1\\n        time.sleep(10)\\n        status, details = get_command_status_with_wait(instance_id, command_id)\\n\\n    retries = 0\\n    return status, details\\n\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"output\",\n      \"Selector\" : \"$.Payload.output\",\n      \"Type\" : \"String\"\n    } ]\n  } ]\n}",
  "CreatedDate": "2023-03-14T16:08:15.701Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "1",
  "Name": "AWS-SetupJupyter",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "08a4fda7-5a34-40cd-bb55-56080c9e5a86",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 11395,
  "HttpStatusCode": 200,
  "LoggedAt": "2023-06-01T07:11:13.2996781+00:00"
}
