{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\" : \"#### Backs up SQL Server databases to a local volume and optionally uploads the backup files to Amazon S3. \\n---\\n#### Prerequisites for using this document:\\n* Instance(s) must be running SQL Server.\\n* An AWS Secrets Manager database credential must be configured with the following two fields: **username** and **password**. For instructions, see [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).\\n* On Windows, the **username** and **password** must be the domain account and password used to authenticate SQL Server. The domain user must be a local administrator.\\n* On Linux, the **username** and **password** must be the SQL Server login  name and password.\\n* The **username** must be assigned, at minimum, the following database role: **sysadmin**. \\n* Instances may need to be granted additional permissions and roles that allow access to AWS Secrets Manager credentials and Amazon S3. For more information, see the [documentation](https://docs.aws.amazon.com/launchwizard/latest/userguide/launch-wizard-sql-provided-runbooks.html).\\n---\\n\\n*Note: This document installs and uses third-party software from [https://ola.hallengren.com](https://ola.hallengren.com), which is provided under the following license: [https://ola.hallengren.com/license.html](https://ola.hallengren.com/license.html)*.\",\n  \"schemaVersion\" : \"0.3\",\n  \"parameters\" : {\n    \"Database\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"^[a-zA-Z_][\\\\w@$#_]{0,127}$\",\n      \"description\" : \"Database to back up\"\n    },\n    \"BackupType\" : {\n      \"type\" : \"String\",\n      \"allowedValues\" : [ \"FULL\", \"DIFF\", \"LOG\" ],\n      \"description\" : \"Select FULL for complete backup, DIFF for differential backup, LOG for transaction log backup\"\n    },\n    \"Directory\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Directory path for the local backup. For example, C:\\\\backup (Windows) or /home/user/backup (Linux)\",\n      \"allowedPattern\" : \"^[a-zA-Z]\\\\:\\\\\\\\[\\\\w_\\\\-\\\\.\\\\\\\\!@#$%^+-9~{},]{1,180}$|^\\\\/[\\\\w_\\\\-\\\\.\\\\/!@#$%^+-9~{},]{1,180}$\"\n    },\n    \"BackupRetentionPolicy\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Retention policy for local backup files\",\n      \"allowedValues\" : [ \"Never delete older backups\", \"Delete older backups after successful backup (specify retention time in DeleteBackupsOlderThan)\", \"Delete older backups before backup (specify retention time in DeleteBackupsOlderThan)\" ],\n      \"default\" : \"Never delete older backups\"\n    },\n    \"DeleteBackupsOlderThan\" : {\n      \"type\" : \"String\",\n      \"default\" : \"0\",\n      \"description\" : \"Retention time, in hours, for local backup files (used by \\\"Delete older backups...\\\");  0 means never delete\",\n      \"allowedPattern\" : \"^[0-9]{1,6}$\"\n    },\n    \"SecretsMangerCredential\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Name of the AWS Secrets Manager database secret\",\n      \"allowedPattern\" : \"^[\\\\/_+=\\\\.@\\\\-a-zA-Z0-9]{1,512}$\"\n    },\n    \"S3Bucket\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"^[a-z0-9-]*$\",\n      \"description\" : \"Optionally specified Amazon S3 bucket name to which to upload backup. Bucket name can only contain alphanumeric characters\",\n      \"default\" : \"\"\n    },\n    \"S3BucketFolder\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"^[a-zA-Z0-9]*$\",\n      \"default\" : \"\",\n      \"description\" : \"Optionally specified non-public Amazon S3 folder to store backups, which must be specified for S3Bucket\"\n    },\n    \"InstanceId\" : {\n      \"type\" : \"StringList\",\n      \"description\" : \"Target SQL Server instance on which to perform the backup operation\",\n      \"allowedPattern\" : \"(^i-(\\\\w{8}|\\\\w{17})$)|(^op-\\\\w{17}$)\"\n    },\n    \"ThirdPartySoftwareConsent\" : {\n      \"type\" : \"String\",\n      \"allowedValues\" : [ \"Yes\" ],\n      \"description\" : \"Consent to the use third-party software mentioned in description\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"GetInstanceOSInfo\",\n    \"action\" : \"aws:executeAwsApi\",\n    \"inputs\" : {\n      \"Service\" : \"ssm\",\n      \"Api\" : \"DescribeInstanceInformation\",\n      \"Filters\" : [ {\n        \"Key\" : \"InstanceIds\",\n        \"Values\" : [ \"{{ InstanceId }}\" ]\n      } ]\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"platform\",\n      \"Selector\" : \"$.InstanceInformationList[0].PlatformType\",\n      \"Type\" : \"String\"\n    } ]\n  }, {\n    \"name\" : \"BranchOnWindowsOrLinux\",\n    \"action\" : \"aws:branch\",\n    \"inputs\" : {\n      \"Choices\" : [ {\n        \"NextStep\" : \"ExecuteBackup\",\n        \"Variable\" : \"{{GetInstanceOSInfo.platform}}\",\n        \"StringEquals\" : \"Windows\"\n      }, {\n        \"NextStep\" : \"InstallPowerShellOnLinux\",\n        \"Variable\" : \"{{GetInstanceOSInfo.platform}}\",\n        \"StringEquals\" : \"Linux\"\n      } ]\n    }\n  }, {\n    \"name\" : \"InstallPowerShellOnLinux\",\n    \"action\" : \"aws:runCommand\",\n    \"inputs\" : {\n      \"DocumentName\" : \"AWS-RunShellScript\",\n      \"InstanceIds\" : \"{{ InstanceId }}\",\n      \"Parameters\" : {\n        \"commands\" : \"if [ \\\"$(which pwsh > /dev/null 2>&1; echo $?)\\\" -ne \\\"0\\\" ]\\nthen\\n   sudo apt-get install -y powershell\\nfi\"\n      }\n    }\n  }, {\n    \"name\" : \"ExecuteBackup\",\n    \"action\" : \"aws:runCommand\",\n    \"inputs\" : {\n      \"DocumentName\" : \"AWS-RunPowerShellScript\",\n      \"InstanceIds\" : \"{{ InstanceId }}\",\n      \"Parameters\" : {\n        \"commands\" : [ \"function VerifySignature { param( [Parameter(Mandatory=$true)] $FilePath, [Parameter(Mandatory=$true)] $SignatureFilePath ) $code = \\\" using System; using System.IO; using System.Security.Cryptography; namespace Crypto { public class CryptoHelper { public static bool VerifySignature(string FilePath, string SignatureFilePath) { try { var modulus = Convert.FromBase64String(\\\"\\\"68hw9z3PIC7u5VkEoWeOI+f63hf3+FTDidjgEYkbsGVJ/8Yip0tIyk7rw84AEA9mlZ8c9k5U0dZo18fLGYhRkfgytLVwaXXU8083DwTGj5n8TvTrKss8ugschfGQJIanyWR7eRFLxuYZS5fo2lxur8K+6rc7yDgM+zQTzoOz2GDcTMm3MY3aST9/SShmJLoc6yoekXifyCebSFt8PZ0lmARFiHupepDrZlqXKY/490MlEiZz2fh7RjOORTDZo85Ai/prxxRuHnXrlIBDCbWfCqPCphJD9IMYcbFUxMfL1M7WXCheAtPpzJjMpdLQ+QIzOY1gdvTxx9ml4BtcdXyyE1BE0gFmR8QHBzJIE6KWE7OSEQpPnqwJ+zkA79Mr9/Ud4gdKeI2rGWN7quspSn7nCXcfbG+j9Rc0JMpKgaVLhfXxC0/xWS6JO4HCgrfh5rXWjAN+HVeHDI2iuPOALrHSUPK9hFudqDWSCEhBO3WcVTeg7dzU2M8rx92ypfbThEhczwXQ3yXGbojUzEPv8M24tOsjDZtPlyErE9xwtVY4UBUuJPsjbxLYx/Bq8Fg79liIVITRDH+UQFGws3YZe8EqSOpyk8hY6rOXXXU0uVLpjMny1tmxngdFRaTnQtNUoqV4NBT1wTTSNKEx/O04fEfU7Jha6oaeZ1NaL4F4wApmAh0=\\\"\\\"); var exponent = Convert.FromBase64String(\\\"\\\"AQAB\\\"\\\"); var rsa = RSA.Create(new RSAParameters {Exponent = exponent, Modulus = modulus}); using (var stream = File.OpenRead(FilePath)) { var signatureBytes = File.ReadAllBytes(SignatureFilePath); var bytesToVerify = SHA256.Create().ComputeHash(stream); return rsa.VerifyData(bytesToVerify, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); } } catch (Exception e) { Console.WriteLine(e.ToString()); return false; } } } } \\\"; Add-Type -TypeDefinition $code -Language CSharp -ErrorAction Stop; return [Crypto.CryptoHelper]::VerifySignature($FilePath, $SignatureFilePath); }\\nfunction ExecuteScript { param( [Parameter(Mandatory=$true)] $ScriptFileName, [Parameter(Mandatory=$true)] $ScriptExpression )\\n$ExitCode = 1; $Result = \\\"\\\"; $TempFolder = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.Guid]::NewGuid()); $null = New-Item -ItemType Directory -Path $TempFolder -ErrorAction Stop; try { $MaintenanceZip = \\\"aws-maintenance.zip\\\"; $MaintenanceZipSig = \\\"aws-maintenance.zip.sig\\\"; $Prefix = \\\"45985c0a-2152-4931-b859-74b2b5f26cb1\\\"; $Stage  = \\\"prod\\\"; $Region = \\\"{{global:REGION}}\\\"; $S3Domain = \\\"s3.amazonaws.com\\\"; if ($Region.Contains(\\\"gov\\\")) { $S3Domain = \\\"s3-$Region.amazonaws.com\\\"; } $URI=\\\"https://launchwizardscript-$Stage-$Region.$S3Domain/$Prefix/Maintenance/\\\"; $ZipFile = Join-Path -Path $TempFolder -ChildPath $MaintenanceZip; $ZipFileSig = Join-Path -Path $TempFolder -ChildPath $MaintenanceZipSig; $ScriptPath = Join-Path -Path $TempFolder -ChildPath \\\"Maintenance\\\"; $ScriptPath = Join-Path -Path $ScriptPath -ChildPath $ScriptFileName; $ProgressPreference = \\\"SilentlyContinue\\\"; $global:ProgressPreference = \\\"SilentlyContinue\\\"; $null = Invoke-WebRequest -Uri ($URI+$MaintenanceZip) -OutFile $ZipFile -ErrorAction Stop; $null = Invoke-WebRequest -Uri ($URI+$MaintenanceZipSig) -OutFile $ZipFileSig -ErrorAction Stop; if ((VerifySignature $ZipFile $ZipFileSig) -ne $true) { throw \\\"Signature validation failed\\\" }; $null = Expand-Archive -Path $ZipFile -DestinationPath $TempFolder -ErrorAction Stop; $ScriptBlock = [scriptblock]::Create(\\\". $ScriptPath; $ScriptExpression\\\"); $Result = Invoke-Command -ScriptBlock $ScriptBlock -ErrorAction Stop; } catch { Write-Output $_.Exception; } finally { $Null = Remove-Item $TempFolder -Recurse -Force -ErrorAction SilentlyContinue; if (($null -eq $Result) -or ($Result.GetType().FullName -eq \\\"System.String\\\")) { Write-Output \\\"Unknown execution failure $Result\\\"; exit(1) } else { $Len = $Result.Length-1; $ExitCode = $Result[$Len]; $Len2 = $Len-1; Write-Output $Result[0..$Len2]; exit($ExitCode) } } } try { Set-StrictMode -Version latest; $Map = @{ \\\"Never delete older backups\\\" = \\\"NeverDelete\\\"; \\\"Delete older backups after successful backup (specify retention time in DeleteBackupsOlderThan)\\\" = \\\"DeleteAfterBackup\\\"; \\\"Delete older backups before backup (specify retention time in DeleteBackupsOlderThan)\\\" = \\\"DeleteBeforeBackup\\\"; }; $S3Bucket = \\\"{{S3Bucket}}\\\"; $S3BucketFolder = \\\"{{S3BucketFolder}}\\\"; $S3Expression = \\\"\\\"; $Directory = \\\"{{Directory}}\\\"; $Database = \\\"{{Database}}\\\"; $SecretsManagerId = \\\"{{SecretsMangerCredential}}\\\"; if (($S3Bucket -ne \\\"\\\") -or ($S3BucketFolder -ne \\\"\\\")) { if (!(($S3Bucket -ne \\\"\\\") -and ($S3BucketFolder -ne \\\"\\\"))) { Write-Output \\\"The S3Bucket and S3Bucket folder must be specified together\\\" exit(1) } $S3Expression = \\\"-S3Bucket {{S3Bucket}} -S3BucketFolder {{S3BucketFolder}}\\\" }; $BackupRetentionPolicy = $Map[\\\"{{BackupRetentionPolicy}}\\\"]; $DeleteBackupsOlderThan = \\\"{{DeleteBackupsOlderThan}}\\\";\\nif ([string]::IsNullOrEmpty($BackupRetentionPolicy) -or [string]::IsNullOrEmpty($DeleteBackupsOlderThan)) { Write-Output \\\"Mismatch in document content\\\"; exit(1); }\\n$ScriptExpression = \\\"BackupDatabase -SecretsManagerId $SecretsManagerId -Databases $Database -BackupType \\\" + \\\"{{BackupType}} -Directory $Directory $S3Expression \\\" + \\\"-BackupRetentionPolicy $BackupRetentionPolicy -DeleteBackupsOlderThan $DeleteBackupsOlderThan\\\"; ExecuteScript -ScriptFileName \\\"aws-sqlbackup.ps1\\\" -ScriptExpression $ScriptExpression; } catch { Write-Output $_.Exception; exit(1) }\" ],\n        \"executionTimeout\" : \"172800\"\n      }\n    },\n    \"timeoutSeconds\" : 172800\n  } ]\n}",
  "CreatedDate": "2022-04-30T02:48:59.409Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "16",
  "Name": "AWSSQLServer-Backup",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "3bf6bdef-9daf-4afb-800b-bca0228e4343",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 11538,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-12-03T07:11:08.3634397+00:00"
}
