{
  "AttachmentsContent": [],
  "Content": "{\r\n  \"schemaVersion\": \"2.2\",\r\n  \"description\": \"Create an application consistent snapshot of all EBS volumes attached to an instance.\",\r\n  \"parameters\": {\r\n    \"ExcludeBootVolume\": {\r\n      \"type\": \"String\",\r\n      \"description\": \"(Optional) Select True to exclude the boot volume from the snapshot process.\",\r\n      \"allowedValues\": [\r\n        \"True\",\r\n        \"False\"\r\n      ],\r\n      \"default\": \"False\"\r\n    },\r\n    \"NoWriters\": {\r\n      \"type\": \"String\",\r\n      \"description\": \"(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.\",\r\n      \"allowedValues\": [\r\n        \"True\",\r\n        \"False\"\r\n      ],\r\n      \"default\": \"False\"\r\n    },\r\n    \"CopyOnly\": {\r\n      \"type\": \"String\",\r\n      \"description\": \"(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.\",\r\n      \"allowedValues\": [\r\n        \"True\",\r\n        \"False\"\r\n      ],\r\n      \"default\": \"False\"\r\n    },\r\n    \"CreateAmi\": {\r\n      \"type\": \"String\",\r\n      \"description\": \"(Optional) Select True to create an Amazon Machine Image (AMI) backup.\",\r\n      \"allowedValues\": [\r\n        \"True\",\r\n        \"False\"\r\n      ],\r\n      \"default\": \"False\"\r\n    },\r\n    \"AmiName\": {\r\n      \"type\": \"String\",\r\n      \"default\": \"\",\r\n      \"description\": \"(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.\",\r\n      \"maxChars\": 128\r\n    },\r\n    \"description\": {\r\n      \"type\": \"String\",\r\n      \"default\": \"\",\r\n      \"description\": \"(Optional) Specify a description to apply to created EBS snaphots.\",\r\n      \"maxChars\": 255\r\n    },\r\n    \"tags\": {\r\n      \"type\": \"String\",\r\n      \"default\": \"Key=Name,Value=\",\r\n      \"description\": \"(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234\",\r\n      \"allowedPattern\": \"^([Kk]ey=(.*),[Vv]alue=(.*);?)*$\"\r\n    }\r\n  },\r\n  \"mainSteps\": [\r\n    {\r\n      \"precondition\": {\r\n        \"StringEquals\": [\r\n          \"platformType\",\r\n          \"Windows\"\r\n        ]\r\n      },\r\n      \"action\": \"aws:runPowerShellScript\",\r\n      \"name\": \"runPowerShellScript\",\r\n      \"inputs\": {\r\n        \"runCommand\": [\r\n\"# Copyright 2017-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\",\r\n\"\",\r\n\"Set-StrictMode -Version Latest\",\r\n\"\",\r\n\"# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001\",\r\n\"$EBS_VOLUME_MATCH = '(?<=vol).*(?=_)'\",\r\n\"# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd\",\r\n\"$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'\",\r\n\"\",\r\n\"$vssAgentPath = \\\"$env:ProgramFiles\\\\Amazon\\\\AwsVssComponents\\\\ec2-vss-agent.exe\\\"\",\r\n\"$vssPath = \\\"$env:ProgramFiles\\\\Amazon\\\\AwsVssComponents\\\\\\\"\",\r\n\"$vssStdErr = $vssPath + 'vsserr.log'\",\r\n\"$vssStdOut = $vssPath + 'vssout.log'\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# ec2-vss-agent.exe runs as a separate process with it's output redirected to a log file.\",\r\n\"# After it completes read the file and output it to the console.\",\r\n\"#\",\r\n\"function PrintVssAgentOutput($process) {\",\r\n\"\",\r\n\"    $process.WaitForExit()\",\r\n\"    $out = Get-Content $vssStdOut\",\r\n\"    if ($out) {\",\r\n\"        $out = [string]::join(\\\"`n\\\", $out)\",\r\n\"        Write-Host $out\",\r\n\"    }\",\r\n\"\",\r\n\"    $out = Get-Content $vssStdErr\",\r\n\"    if ($out) {\",\r\n\"        $out = [string]::join(\\\"`n\\\", $out)\",\r\n\"        Write-Host $out\",\r\n\"    }\",\r\n\"}\",\r\n\"\",\r\n\"#\",\r\n\"# Function to begin the VSS snapshot of a EBS volume\",\r\n\"#\",\r\n\"function EbsVssFreeze {\",\r\n\"    param (\",\r\n\"        [string]$driveLetter,\",\r\n\"        [DateTime]$startTime,\",\r\n\"        [boolean]$copyOnly,\",\r\n\"        [boolean]$noWriters\",\r\n\"    )\",\r\n\"\",\r\n\"    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second\",\r\n\"    # if the named pipe server creation fails we know another instance of this script is running.\",\r\n\"    if ((get-process \\\"ec2-vss-agent\\\" -ea SilentlyContinue) -ne $Null) { \",\r\n\"        Write-Host \\\"ec2-vss-agent is current running, snapshot already in progress.\\\" \",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    try {\",\r\n\"        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'\",\r\n\"        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, \",\r\n\"            [System.IO.Pipes.PipeDirection]::In,\",\r\n\"            1,\",\r\n\"            [System.IO.Pipes.PipeTransmissionMode]::Byte,\",\r\n\"            [System.IO.Pipes.PipeOptions]::Asynchronous)\",\r\n\"\",\r\n\"        $asyncResult = $pipeServer.WaitForConnectionAsync()\",\r\n\"\",\r\n\"        Write-Host 'Pipe server started after' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"    } catch {\",\r\n\"        Write-Host \\\"Pipe server failed to start.  Possibly another instance of this script is running.\\\"\",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    $params = $driveLetter\",\r\n\"\",\r\n\"    if ($copyOnly) {\",\r\n\"        Write-Host \\\"Copy only option selected\\\"\",\r\n\"        $params = \\\"-copy \\\" + $params\",\r\n\"    }\",\r\n\"\",\r\n\"    if ($noWriters) {\",\r\n\"        Write-Host \\\"No writers option selected\\\"\",\r\n\"        $params = \\\"-nw \\\" + $params\",\r\n\"    }\",\r\n\"\",\r\n\"    $process = Start-Process $vssAgentPath $params -PassThru -RedirectStandardError $vssStdErr -RedirectStandardOutput $vssStdOut\",\r\n\"    if ($process -eq $null) {\",\r\n\"        return $false\",\r\n\"    }\",\r\n\"\",\r\n\"    Write-Host 'Waiting for Freeze pipe at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"\",\r\n\"    #\",\r\n\"    # Wait up to 10 minutes for connection from provider indicating VSS freeze has begun.\",\r\n\"    # Some VSS writers can delay the snapshot process so we must wait enough time for all writers to complete.\",\r\n\"    #\",\r\n\"    try {\",\r\n\"        if ($asyncResult.AsyncWaitHandle.WaitOne(10 * 60 * 1000)){\",\r\n\"            Write-Host 'Freeze pipe connected at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"            $pipeReader = new-object System.IO.StreamReader($pipeServer)\",\r\n\"            $string = $pipeReader.ReadLine()\",\r\n\"            Write-Host 'EBS snapshot Freeze message received at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms' $string\",\r\n\"        } else {\",\r\n\"            Write-Host \\\"Timeout waiting for VSS Freeze\\\"\",\r\n\"            PrintVssAgentOutput $process\",\r\n\"            $process = $null\",\r\n\"        }\",\r\n\"    } catch {\",\r\n\"        Write-Host \\\"Freeze pipe read failed at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        Write-Error  $_\",\r\n\"    } finally {\",\r\n\"        Write-Host 'Disposing of pipes at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }\",\r\n\"        $pipeServer.Dispose()\",\r\n\"        $asyncResult.AsyncWaitHandle.Close()\",\r\n\"    }\",\r\n\"\",\r\n\"    return $process\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Function to release VSS freeze of EBS volume after snapshot is complete.\",\r\n\"#\",\r\n\"function EbsVssThaw($startTime = (Get-Date)) {\",\r\n\"\",\r\n\"    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'\",\r\n\"    $string = [string]::Empty\",\r\n\"\",\r\n\"    try {\",\r\n\"        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\\\".\\\",\",\r\n\"            $namedPipe, \",\r\n\"            [System.IO.Pipes.PipeDirection]::In,\",\r\n\"            [System.IO.Pipes.PipeOptions]::Asynchronous)\",\r\n\"\",\r\n\"        Write-Host \\\"Thaw pipe waiting for connection at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        # Wait for thaw connection from provider\",\r\n\"        $pipeClient.Connect(10000)\",\r\n\"        Write-Host \\\"Thaw pipe connected at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        try {\",\r\n\"            $pipeReader = new-object System.IO.StreamReader($pipeClient)\",\r\n\"            $string = $pipeReader.ReadLine()\",\r\n\"        } catch {\",\r\n\"            Write-Host \\\"Thaw pipe read failed at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"            Write-Error  $_\",\r\n\"        } finally {\",\r\n\"            $pipeReader.Dispose()\",\r\n\"        }\",\r\n\"    } catch {\",\r\n\"        Write-Host \\\"Thaw pipe connection failed at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        Write-Error  $_\",\r\n\"    } finally {\",\r\n\"        $pipeClient.Dispose()\",\r\n\"    }\",\r\n\"\",\r\n\"    Write-Host \\\"Pipe message read at\\\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"\",\r\n\"    if ($string -like 'EBS done') {\",\r\n\"        return $true\",\r\n\"    } else {\",\r\n\"        Write-Host \\\"Thaw pipe returned wrong value: \\\" $string \",\r\n\"        return $false\",\r\n\"    }\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Helper function to retrieve EC2 instance meta-data.\",\r\n\"#\",\r\n\"function Get-EC2InstanceMetadata {\",\r\n\"    param([string]$Path)\",\r\n\"\",\r\n\"    try {\",\r\n\"        ## Attempt v1 IMDS API\",\r\n\"        return Invoke-RestMethod -Method \\\"GET\\\" -URI \\\"http://169.254.169.254/latest/$Path\\\"\",\r\n\"    } catch {\",\r\n\"        ## IMDSv1 not supported, will attempt IMDSv2\",\r\n\"        $Token = [string](Invoke-RestMethod -Method \\\"PUT\\\" -URI \\\"http://169.254.169.254/latest/api/token\\\" `\",\r\n\"                    -Headers @{\\\"X-aws-ec2-metadata-token-ttl-seconds\\\"=\\\"1200\\\"})\",\r\n\"        $Headers = @{\\\"X-aws-ec2-metadata-token\\\"=$Token}\",\r\n\"        return Invoke-RestMethod -Method \\\"GET\\\" -URI \\\"http://169.254.169.254/latest/$Path\\\" -Headers $Headers\",\r\n\"    }\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Helper function to convert SCSI target ID to xvd* EBS device name.\",\r\n\"#\",\r\n\"function Convert-SCSITargetIdToDeviceName {\",\r\n\"    param([int]$SCSITargetId)\",\r\n\"    If ($SCSITargetId -eq 0) {\",\r\n\"        return '/dev/sda1'\",\r\n\"    }\",\r\n\"    $deviceName = 'xvd'\",\r\n\"    If ($SCSITargetId -gt 25) {\",\r\n\"        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))\",\r\n\"    }\",\r\n\"    $deviceName += [char](0x61 + $SCSITargetId % 26)\",\r\n\"    return $deviceName\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types\",\r\n\"#\",\r\n\"function Get-AwsNvmeStorageSpacesEbsDiskMapping {\",\r\n\"    \",\r\n\"    $disklist = @()\",\r\n\"    $physicalDisks = @()\",\r\n\"\",\r\n\"    # Exit if we are not on at least Server 2012\",\r\n\"    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {\",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    $physicalDisks += Get-PhysicalDisk | Where-Object {\",\r\n\"        $_.Manufacturer -match 'NVMe' -and $_.Model -match 'Amazon' -and\",\r\n\"        ( $_.SerialNumber -match $EBS_VOLUME_MATCH -or\",\r\n\"        ( (Get-Member -InputObject $_ -Name \\\"AdapterSerialNumber\\\") -and $_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))\",\r\n\"    }\",\r\n\"    \",\r\n\"    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {\",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    $InstanceId = Get-EC2InstanceMetadata \\\"meta-data/instance-id\\\"\",\r\n\"\",\r\n\"    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings\",\r\n\"    \",\r\n\"    foreach ($pd in $physicalDisks) {\",\r\n\"\",\r\n\"        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue\",\r\n\"\",\r\n\"        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }\",\r\n\"        \",\r\n\"        if ($volumeNumber -eq $null) {\",\r\n\"            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }\",\r\n\"        }\",\r\n\"\",\r\n\"        $ebsVolumeId = \\\"vol-$volumeNumber\\\"\",\r\n\"        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}\",\r\n\"\",\r\n\"        foreach ($vd in Get-VirtualDisk) {\",\r\n\"            $pool2 = Get-StoragePool -VirtualDisk $vd\",\r\n\"            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {\",\r\n\"                $disk = ($vd | Get-Disk)\",\r\n\"                $parts = @($disk | Get-Partition)\",\r\n\"                foreach ($part in $parts) {\",\r\n\"                    $vol = ($part | Get-Volume)\",\r\n\"                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)\",\r\n\"                    $diskList += New-Object PSObject -Property @{\",\r\n\"                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };\",\r\n\"                        Partitions    = 0;\",\r\n\"                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };\",\r\n\"                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };\",\r\n\"                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };\",\r\n\"                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };\",\r\n\"                        IsReadOnly    = $isReadOnly;\",\r\n\"                    }\",\r\n\"                }\",\r\n\"            }\",\r\n\"        }\",\r\n\"    }\",\r\n\"\",\r\n\"    return $disklist\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Retrieve EBS volumes associated with a Storage Spaces pool \",\r\n\"#\",\r\n\"function Get-XenStorageSpacesEbsDiskMapping {\",\r\n\"    \",\r\n\"    $disklist = @()\",\r\n\"    $physicalDisks = @()\",\r\n\"\",\r\n\"    # Older versions of XenVBD use the attachment point to determine serial number\",\r\n\"    $ATTACHMENT_ORDER_MATCH = '^(\\\\d{4})$'\",\r\n\"\",\r\n\"    # Exit if we are not on at least Server 2012\",\r\n\"    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {\",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    $physicalDisks += Get-PhysicalDisk | Where-Object {\",\r\n\"        ( ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or\",\r\n\"        $_.SerialNumber -match $EBS_VOLUME_MATCH2 ) -and\",\r\n\"        $_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'\",\r\n\"    }\",\r\n\"    \",\r\n\"    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {\",\r\n\"        return $null\",\r\n\"    }\",\r\n\"\",\r\n\"    $InstanceId = Get-EC2InstanceMetadata \\\"meta-data/instance-id\\\"\",\r\n\"\",\r\n\"    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings\",\r\n\"\",\r\n\"    foreach ($pd in $physicalDisks) {\",\r\n\"        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }\",\r\n\"        if ($volumeNumber -ne $null) {\",\r\n\"            $ebsVolumeId = \\\"vol-$volumeNumber\\\"\",\r\n\"            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }\",\r\n\"            if ($device -ne $null) {\",\r\n\"                $BlockDeviceName = $device.DeviceName\",\r\n\"            }\",\r\n\"            else {\",\r\n\"                $ebsVolumeId = $null\",\r\n\"            }\",\r\n\"        }\",\r\n\"        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {\",\r\n\"            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber\",\r\n\"            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\\\"*\\\" + $BlockDeviceName)}\",\r\n\"            if ($device -ne $null) {\",\r\n\"                $ebsVolumeId = $device.Ebs.VolumeId\",\r\n\"            }\",\r\n\"            else {\",\r\n\"                $ebsVolumeId = $null\",\r\n\"            }\",\r\n\"        }\",\r\n\"        else {\",\r\n\"            $ebsVolumeId = $null\",\r\n\"        }\",\r\n\"\",\r\n\"        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue\",\r\n\"\",\r\n\"        foreach ($vd in Get-VirtualDisk) {\",\r\n\"            $pool2 = Get-StoragePool -VirtualDisk $vd\",\r\n\"            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {\",\r\n\"                $disk = ($vd | Get-Disk)\",\r\n\"                $parts = @($disk | Get-Partition)\",\r\n\"                foreach ($part in $parts) {\",\r\n\"                    $vol = ($part | Get-Volume)\",\r\n\"                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)\",\r\n\"                    $diskList += New-Object PSObject -Property @{\",\r\n\"                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };\",\r\n\"                        Partitions    = 0;\",\r\n\"                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };\",\r\n\"                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };\",\r\n\"                        Device        = If ($pd -eq $null) { $null } Else { $device.DeviceName };\",\r\n\"                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };\",\r\n\"                        IsReadOnly    = $isReadOnly;\",\r\n\"                    }\",\r\n\"                }\",\r\n\"            }\",\r\n\"        }\",\r\n\"    }\",\r\n\"\",\r\n\"    return $disklist\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Helper function to collect connected EBS volumes attached to local EC2 instance.\",\r\n\"#\",\r\n\"function Get-EbsDiskMapping {\",\r\n\"\",\r\n\"    Try {\",\r\n\"        $InstanceId = Get-EC2InstanceMetadata \\\"meta-data/instance-id\\\"\",\r\n\"        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings\",\r\n\"    } Catch {\",\r\n\"        Write-Host \\\"Could not access the AWS API, therefore, VolumeId is not available. \",\r\n\"        Verify that your instance role has Describe-Instances permission.\\\" -ForegroundColor Yellow\",\r\n\"        throw\",\r\n\"    }\",\r\n\"\",\r\n\"    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {\",\r\n\"        $DiskDrive = $_\",\r\n\"        $Volumes = Get-WmiObject -Query \\\"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\\\" | ForEach-Object {\",\r\n\"            $DiskPartition = $_\",\r\n\"            Get-WmiObject -Query \\\"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\\\"\",\r\n\"        }\",\r\n\"        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }\",\r\n\"        if ($volumeNumber -eq $null) {\",\r\n\"            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }\",\r\n\"        }\",\r\n\"        if ($volumeNumber -ne $null) {\",\r\n\"            $ebsVolumeId = \\\"vol-$volumeNumber\\\"\",\r\n\"            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }\",\r\n\"            if ($BlockDevice -ne $null) {\",\r\n\"                $BlockDeviceName = $BlockDevice.DeviceName\",\r\n\"            }\",\r\n\"        }\",\r\n\"        elseif ($DiskDrive.PNPDeviceID -like \\\"*PROD_PVDISK*\\\") {\",\r\n\"            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)\",\r\n\"            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\\\"*\\\" + $BlockDeviceName) }\",\r\n\"        }\",\r\n\"        else {\",\r\n\"            $BlockDeviceName = $null\",\r\n\"            $BlockDevice = $null\",\r\n\"        }\",\r\n\"\",\r\n\"        $foundWriteableVolume = $false\",\r\n\"        foreach ($volume in $Volumes) {\",\r\n\"            if ($volume.Access -ne 1) {\",\r\n\"                $foundWriteableVolume = $true\",\r\n\"            }\",\r\n\"        }\",\r\n\"\",\r\n\"        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {\",\r\n\"            New-Object PSObject -Property @{\",\r\n\"                Disk          = $DiskDrive.Index;\",\r\n\"                Partitions    = $DiskDrive.Partitions;\",\r\n\"                DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };\",\r\n\"                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };\",\r\n\"                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };\",\r\n\"                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };\",\r\n\"                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };\",\r\n\"            }\",\r\n\"        }\",\r\n\"    } | Sort-Object Disk\",\r\n\"\",\r\n\"    return $diskList\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Get a mapping of the local drives to EBS volumes\",\r\n\"#\",\r\n\"function Get-EbsConnectedVolume\",\r\n\"{\",\r\n\"    $diskList = @()\",\r\n\"\",\r\n\"    # If any of the functions return $null it will be added to the disk list which we do not want!\",\r\n\"    $disks = Get-EbsDiskMapping\",\r\n\"    if ($disks) {\",\r\n\"        $diskList += $disks\",\r\n\"    }\",\r\n\"\",\r\n\"    $disks =  Get-XenStorageSpacesEbsDiskMapping\",\r\n\"    if ($disks) {\",\r\n\"        $diskList += $disks\",\r\n\"    }\",\r\n\"\",\r\n\"    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping\",\r\n\"    if ($disks) {\",\r\n\"        $diskList += $disks\",\r\n\"    }\",\r\n\"\",\r\n\"    return $diskList\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"#\",\r\n\"# Tag Snapshots\",\r\n\"#\",\r\n\"function Tag-Snapshots {\",\r\n\"    param(\",\r\n\"        [System.Object[]]$SnapshotsData,\",\r\n\"        [System.Object]$AmiData,\",\r\n\"        [boolean]$AppConsistent,\",\r\n\"        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags\",\r\n\"    )\",\r\n\"    $Tag = new-object amazon.EC2.Model.Tag\",\r\n\"    $Tag.Key = \\\"AppConsistent\\\"\",\r\n\"    $Tag.Value = \\\"$AppConsistent\\\"\",\r\n\"    $Tags += $Tag\",\r\n\"    foreach ($SnapshotData in $SnapshotsData) {\",\r\n\"        $Tag = new-object amazon.EC2.Model.Tag\",\r\n\"        $Tag.Key = \\\"Device\\\"\",\r\n\"        $Tag.Value = $SnapshotData.Device\",\r\n\"        $AllTags = $Tags + $Tag\",\r\n\"        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags\",\r\n\"    }\",\r\n\"\",\r\n\"    if ($AmiData) {\",\r\n\"        New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags\",\r\n\"    }\",\r\n\"}\",\r\n\"\",\r\n\"function VssSnapshot() {\",\r\n\"    param(\",\r\n\"        [boolean]$ExcludeBootVolume,\",\r\n\"        [boolean]$CopyOnly,\",\r\n\"        [boolean]$NoWriters,\",\r\n\"        [boolean]$CreateAmi,\",\r\n\"        [string]$AmiName,\",\r\n\"        [string]$Description,\",\r\n\"        [string]$Tags\",\r\n\"    )\",\r\n\"    $startTime = Get-Date\",\r\n\"    $VolumesToFreeze = @()\",\r\n\"    $VolumesToFreezeString = @()\",\r\n\"    $DrivesToFreeze = @()\",\r\n\"\",\r\n\"    if ($ExcludeBootVolume -and $CreateAmi) {\",\r\n\"        Write-Host \\\"The CreateAMI option is not compatible with ExcludeBootVolume.\\\"\",\r\n\"        return $false\",\r\n\"    }\",\r\n\"\",\r\n\"    if (!(Test-Path $vssAgentPath)) {\",\r\n\"        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'\",\r\n\"        return $false\",\r\n\"    }\",\r\n\"\",\r\n\"    # Remove previous agent log files\",\r\n\"    if (Test-Path $vssStdErr) {\",\r\n\"        del $vssStdErr\",\r\n\"    }\",\r\n\"    if (Test-Path $vssStdOut) {\",\r\n\"        del $vssStdOut\",\r\n\"    }\",\r\n\"\",\r\n\"    $InstanceId = Get-EC2InstanceMetadata \\\"meta-data/instance-id\\\"\",\r\n\"\",\r\n\"    $volumeList = Get-EbsConnectedVolume\",\r\n\"    $foundWriteableVolume = $false\",\r\n\"    foreach ($v in $volumeList) {\",\r\n\"        if ( ($v.DriveLetter -ne $null) -and ($v.EbsVolumeId -ne $null)) {\",\r\n\"            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \\\"/dev/sda1\\\")) {\",\r\n\"                $VolumesToFreezeString += ($v.DriveLetter -join ' ') + \\\" \\\"\",\r\n\"                $DrivesToFreeze += $v.DriveLetter\",\r\n\"                $VolumesToFreeze += $v\",\r\n\"                if (-not $v.IsReadOnly) {\",\r\n\"                    $foundWriteableVolume = $true\",\r\n\"                }\",\r\n\"            }\",\r\n\"        }\",\r\n\"    }\",\r\n\"    if ($VolumesToFreeze.Count -eq 0) {\",\r\n\"        Write-Host \\\"No mounted EBS drives detected\\\"\",\r\n\"        return $false\",\r\n\"    }\",\r\n\"\",\r\n\"    # AMI name is required and must be unique.  If it is not specified create a AMI name from instance ID, OS version,\",\r\n\"    # and time stamp.\",\r\n\"    if ($createAmi -And (-Not $amiName)) {\",\r\n\"        $amiName = \\\"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\\\"\",\r\n\"        $amiName = $amiName.replace(' ','')\",\r\n\"    }\",\r\n\"\",\r\n\"    if ($foundWriteableVolume) {\",\r\n\"        $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '\",\r\n\"\",\r\n\"        Write-Host \\\"Beginning snapshot for drives\\\" $DrivesToFreezeString\",\r\n\"\",\r\n\"        $process = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters\",\r\n\"        if ($process -eq $null) {\",\r\n\"            return $false\",\r\n\"        }\",\r\n\"\",\r\n\"        Write-Host 'Freeze complete at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"    }\",\r\n\"    else {\",\r\n\"        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'\",\r\n\"    }\",\r\n\"\",\r\n\"    $SnapshotData = @()\",\r\n\"    $AmiData = @()\",\r\n\"    if ($createAmi) {\",\r\n\"         try {\",\r\n\"            $amiId = New-EC2Image -InstanceId $InstanceId -Name $amiName -Description $Description -NoReboot $true\",\r\n\"            Write-Host \\\"AMI: $amiId\\\"\",\r\n\"            $timeOut = 10\",\r\n\"            while ($timeOut) {\",\r\n\"                $AmiData = Get-EC2Image -ImageId $amiId\",\r\n\"                if ($AmiData -And\",\r\n\"                   ($AmiData.BlockDeviceMapping -And\",\r\n\"                   ($AmiData.BlockDeviceMapping.Ebs.Count -eq $VolumesToFreeze.Count)) -And\",\r\n\"                   ($AmiData.State -Like \\\"pending\\\" -Or $AmiData.State -Like \\\"available\\\")) {\",\r\n\"                    break\",\r\n\"                }\",\r\n\"                Start-Sleep -Seconds 1\",\r\n\"                $timeOut--\",\r\n\"            }\",\r\n\"            if ($timeOut -le 0) {\",\r\n\"                Write-Host \\\"Error waiting for AMI\\\"\",\r\n\"                return $false\",\r\n\"            } \",\r\n\"            foreach ($b in $AmiData.BlockDeviceMapping) {\",\r\n\"                Write-Host \\\"Snapshot: $($b.Ebs.SnapshotId), DeviceName: $($b.DeviceName)\\\"\",\r\n\"                $SnapshotData += New-Object PSObject -Property @{\",\r\n\"                    Device      = $b.DeviceName\",\r\n\"                    SnapshotId  = $b.Ebs.SnapshotId\",\r\n\"                }\",\r\n\"            }\",\r\n\"         } catch {\",\r\n\"            Write-Host \\\"Exception caught creating AMI:\\\"\",\r\n\"            Write-Host $_\",\r\n\"            return $false\",\r\n\"        }\",\r\n\"    } else {\",\r\n\"        foreach ($v in $VolumesToFreeze) {\",\r\n\"            if ($SnapshotData | Where-Object {$_.EbsVolumeId -eq $v.EbsVolumeId}) {\",\r\n\"                continue\",\r\n\"            }\",\r\n\"            try {\",\r\n\"                $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $Description\",\r\n\"            } catch {\",\r\n\"                Write-Host \\\"Exception caught creating EBS snapshot:\\\"\",\r\n\"                Write-Host $_\",\r\n\"                return $false\",\r\n\"            }\",\r\n\"            $SnapshotData += New-Object PSObject -Property @{\",\r\n\"                EbsVolumeId = $v.EbsVolumeId\",\r\n\"                Device      = $v.Device\",\r\n\"                SnapshotId  = $Snapshot.SnapshotId\",\r\n\"            }\",\r\n\"            Write-Host \\\"Snapshot: $($Snapshot.SnapshotId), EBS: $($v.EbsVolumeId), DeviceName: $($v.Device)\\\"\",\r\n\"        }\",\r\n\"    }\",\r\n\"\",\r\n\"    if ($foundWriteableVolume) {\",\r\n\"        Write-Host 'Starting Thaw at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        $AppConsistent = EbsVssThaw $startTime\",\r\n\"        if ($AppConsistent) {\",\r\n\"            Write-Host 'Thaw successful at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        } else {\",\r\n\"            Write-Host 'Thaw unsuccesful, snapshots may not be app consistent, see event log for more details' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'\",\r\n\"        }\",\r\n\"\",\r\n\"        PrintVssAgentOutput $process\",\r\n\"    }\",\r\n\"    else {\",\r\n\"        $AppConsistent = $true\",\r\n\"        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'\",\r\n\"    }\",\r\n\"\",\r\n\"    [amazon.EC2.Model.Tag[]]$TagArray = @()\",\r\n\"    $Tags -split \\\";\\\" | ForEach-Object {\",\r\n\"        if (-not [string]::IsNullOrEmpty($_)) {\",\r\n\"            $TagParts = ($_ -split \\\",\\\", 2)\",\r\n\"            if ($TagParts.Count -ne 2) {\",\r\n\"                Write-Host \\\"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\\\"\",\r\n\"                return $false\",\r\n\"            }\",\r\n\"            $TagName, $TagValue = $TagParts\",\r\n\"            $Tag = new-object amazon.EC2.Model.Tag\",\r\n\"            $Tag.Key = ($TagName -split \\\"=\\\", 2)[1].Trim()\",\r\n\"            $Tag.Value = ($TagValue -split \\\"=\\\", 2)[1].Trim()\",\r\n\"            $TagArray += $Tag\",\r\n\"        }\",\r\n\"    }\",\r\n\"\",\r\n\"    Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray\",\r\n\"    return $AppConsistent\",\r\n\"}\",\r\n\"\",\r\n\"\",\r\n\"[boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\\\"{{ExcludeBootVolume}}\\\")\",\r\n\"\",\r\n\"[boolean]$CopyOnly = [System.Convert]::ToBoolean(\\\"{{CopyOnly}}\\\")\",\r\n\"\",\r\n\"[boolean]$NoWriters = [System.Convert]::ToBoolean(\\\"{{NoWriters}}\\\")\",\r\n\"\",\r\n\"[boolean]$CreateAmi = [System.Convert]::ToBoolean(\\\"{{CreateAmi}}\\\")\",\r\n\"\",\r\n\"$AmiName = @\\\"\",\r\n\"{{AmiName}}\",\r\n\"\\\"@\",\r\n\"\",\r\n\"$description = @\\\"\",\r\n\"{{description}}\",\r\n\"\\\"@\",\r\n\"\",\r\n\"$tags = @\\\"\",\r\n\"{{tags}}\",\r\n\"\\\"@\",\r\n\"\",\r\n\"$AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $CreateAmi $AmiName $description $tags\",\r\n\"exit [int](-not $AppConsistent)\",\r\n\"\"\r\n        ],\r\n        \"workingDirectory\": \"\",\r\n        \"timeoutSeconds\": \"400\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n",
  "CreatedDate": "2020-05-14T19:27:46.788Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Command"
  },
  "DocumentVersion": "8",
  "Name": "arn:aws:ssm:us-west-2:187365388452:document/CreateVssSnapshot",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "b60e4709-cfab-424e-9e5b-df286b02a822",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 32700,
  "HttpStatusCode": 200,
  "LoggedAt": "2023-02-13T07:13:26.959178+00:00"
}
