{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\": \"This runbook helps identifying working snapshot (if any) of an EC2 instance and restore the EC2 instance with this identified snapshot.\",\n  \"schemaVersion\": \"0.3\",\n  \"assumeRole\": \"{{ AutomationAssumeRole }}\",\n  \"outputs\": [\n    \"launchCloneInstance.InstanceIds\",\n    \"ListSnapshotByDate.finalSnapshots\",\n    \"ListSnapshotByDate.remainingSnapshotToBeCheckedInSameDateRange\",\n    \"findWorkingSnapshot.workingSnapshot\",\n    \"InstanceRecovery.result\"\n  ],\n  \"parameters\": {\n    \"InstanceId\": {\n      \"type\": \"String\",\n      \"description\": \"The Instance Id of the EC2 Instance you need to restore from Snapshot.\",\n      \"allowedPattern\": \"^i-[a-z0-9]{8,17}$\"\n    },\n    \"SnapshotId\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) If you already have a snapshot Id you want to restore from, you can enter it here.\",\n      \"default\": \"\",\n      \"allowedPattern\": \"^$|^snap-[a-z0-9]{8,17}$\"\n    },\n    \"InplaceSwap\": {\n      \"type\": \"Boolean\",\n      \"description\": \"(Optional) If you wish to replace new volume in your exisiting instance or launch a new instance.\"\n    },\n    \"StartDate\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The Start date for which we need to look for snapshot.\",\n      \"default\": \"\",\n      \"allowedPattern\": \"^$|^(19|20)\\\\d\\\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\"\n    },\n    \"EndDate\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The end date for which we need to look for snapshot.\",\n      \"default\": \"\",\n      \"allowedPattern\": \"^$|^(19|20)\\\\d\\\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\"\n    },\n    \"LookForInstancetStatusCheck\": {\n      \"description\": \" (Optional) To look for first instance status check failed in given time range in order to filter out snapshots more efficiently.  Default is set to \\u2018True\\u2019.\",\n      \"type\": \"Boolean\",\n      \"default\": true\n    },\n    \"TotalSnapshotsToLook\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) Determines how many snapshots automation will look in a single execution.\",\n      \"default\": \"\",\n      \"allowedPattern\": \"^$|^[1-2]$\"\n    },\n    \"skipSnapshotsBy\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) Number of snapshots to be skipped while looking. For example if there are 100 snapshots available in an input time range and 'skipSnapshotsBy' value is set to 2 then every third snapshot will be taken into consideration for execution.\",\n      \"default\": \"0\",\n      \"allowedPattern\": \"^$|^[0-4]$\"\n    },\n    \"AutomationAssumeRole\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that runs this document.\",\n      \"default\": \"\"\n    }\n  },\n  \"mainSteps\": [\n    {\n      \"name\": \"describeInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"outputs\": [\n        {\n          \"Name\": \"InstanceType\",\n          \"Selector\": \"$.Reservations[0].Instances[0].InstanceType\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"AvailabilityZone\",\n          \"Selector\": \"$.Reservations[0].Instances[0].Placement.AvailabilityZone\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"RootVolId\",\n          \"Selector\": \"$.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"SecurityGroupIds\",\n          \"Selector\": \"$.Reservations[0].Instances[0].SecurityGroups..GroupId\",\n          \"Type\": \"StringList\"\n        },\n        {\n          \"Name\": \"KeyName\",\n          \"Selector\": \"$.Reservations[0].Instances[0].KeyName\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"SubnetId\",\n          \"Selector\": \"$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"rootDeviceName\",\n          \"Selector\": \"$.Reservations[0].Instances[0].RootDeviceName\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"Platform\",\n          \"Selector\": \"$.Reservations[0].Instances[0].Platform\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ]\n      },\n      \"description\": \"describe the instance.\"\n    },\n    {\n      \"name\": \"checkInstanceisNotTerminated\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].State.Name\",\n        \"DesiredValues\": [\n          \"running\",\n          \"stopped\"\n        ],\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ]\n      },\n      \"description\": \"checks if the instance is available or not\"\n    },\n    {\n      \"name\": \"assertRootVolumeIsEbs\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"DesiredValues\": [\n          \"ebs\"\n        ],\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].RootDeviceType\",\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ]\n      },\n      \"description\": \"check root vol is ebs\"\n    },\n    {\n      \"name\": \"checkForConcurrentExecution\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeTags\",\n        \"PropertySelector\": \"$.Tags\",\n        \"DesiredValues\": [\n          \"[]\"\n        ],\n        \"Filters\": [\n          {\n            \"Name\": \"resource-id\",\n            \"Values\": [\n              \"{{ InstanceId}}\"\n            ]\n          },\n          {\n            \"Name\": \"key\",\n            \"Values\": [\n              \"SSMExecutionStatusOn\"\n            ]\n          }\n        ]\n      },\n      \"description\": \"This will check if any other SSM documentation is running simultaneously at this moment.\"\n    },\n    {\n      \"name\": \"AddTagsOnOriginalInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"description\": \"This step adds tag on input instance which indicates that this instance is currently being used by SSM.\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"CreateTags\",\n        \"Resources\": [\n          \"{{InstanceId}}\"\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"SSMExecutionStatusOn\",\n            \"Value\": \"Yes\"\n          }\n        ]\n      }\n    },\n    {\n      \"name\": \"createImageWithNoReboot\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"CreateImage\",\n        \"InstanceId\": \"{{ InstanceId }}\",\n        \"Name\": \"AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"ImageId\",\n          \"Selector\": \"$.ImageId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"describeOriginalInstanceImage\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeImages\",\n        \"Filters\": [\n          {\n            \"Name\": \"name\",\n            \"Values\": [\n              \"AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID }}\"\n            ]\n          }\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"ImageId\",\n          \"Selector\": \"$.Images[0].ImageId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"waitTillOriginalInstanceImageImageReady\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeImages\",\n        \"DesiredValues\": [\n          \"available\"\n        ],\n        \"PropertySelector\": \"$.Images[0].State\",\n        \"ImageIds\": [\n          \"{{ describeOriginalInstanceImage.ImageId }}\"\n        ]\n      },\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"launchCloneInstance\",\n      \"action\": \"aws:executeScript\",\n      \"inputs\": {\n        \"Runtime\": \"python3.6\",\n        \"Handler\": \"launchCloneInstance\",\n        \"Script\": \"import json\\nimport boto3\\ndef launchCloneInstance(events, context):\\n  \\n    client = boto3.client(\\n        'ec2'\\n    )\\n    instanceId = ''\\n    InstanceIds = []\\n    try:\\n        runInstance = client.run_instances(\\n                    ImageId=events['ImageId'],\\n                    InstanceType=events['InstanceType'],\\n                    KeyName=events['KeyName'],\\n                    MaxCount=1,\\n                    MinCount=1,\\n                    SecurityGroupIds=\\n                      events['SecurityGroupIds']\\n                    ,\\n                    SubnetId=events['SubnetId'],\\n                    TagSpecifications=[\\n                        {\\n                            'ResourceType': 'instance',\\n                            'Tags': [\\n                                {\\n                                    'Key': 'Name',\\n                                    'Value': 'AWSSupport-RestoreFromSnapshot'\\n                                },\\n                            ]\\n                        },\\n                    ]\\n        )\\n        instanceId = runInstance['Instances'][0]['InstanceId']\\n        if instanceId:\\n            client.get_waiter('instance_running').wait(\\n                        InstanceIds=[\\n                                instanceId\\n                                ],\\n                    \\n                        WaiterConfig={\\n                            'Delay':30,\\n                            'MaxAttempts':30\\n                            }\\n                            )\\n            instanceStatus = client.describe_instances(\\n                                        InstanceIds=[\\n                                            instanceId\\n                                                    ]\\n                                    )\\n            if instanceStatus['Reservations'][0]['Instances'][0]['State']['Name']=='running':\\n                print(\\\"Instance is running\\\")\\n                InstanceIds.append(instanceId)\\n\\n            \\n\\n    except Exception as e:\\n                print('***Failed to launch the instance')\\n                print(type(e), ':', e) \\n    \\n    return {'InstanceIds':InstanceIds, 'InstanceId':InstanceIds[0]}\\n\",\n        \"InputPayload\": {\n          \"ImageId\": \"{{ describeOriginalInstanceImage.ImageId }}\",\n          \"InstanceType\": \"{{ describeInstance.InstanceType }}\",\n          \"SubnetId\": \"{{ describeInstance.SubnetId }}\",\n          \"KeyName\": \"{{ describeInstance.KeyName }}\",\n          \"SecurityGroupIds\": \"{{ describeInstance.SecurityGroupIds }}\",\n          \"AutomationId\": \"{{ automation:EXECUTION_ID }}\"\n        }\n      },\n      \"maxAttempts\": 3,\n      \"nextStep\": \"waitTillInstanceIsReady\",\n      \"timeoutSeconds\": 7200,\n      \"outputs\": [\n        {\n          \"Selector\": \"$.Payload.InstanceIds\",\n          \"Type\": \"StringList\",\n          \"Name\": \"InstanceIds\"\n        },\n        {\n          \"Name\": \"InstanceId\",\n          \"Selector\": \"$.Payload.InstanceId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"waitTillInstanceIsReady\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"InstanceIds\": [\n          \"{{ launchCloneInstance.InstanceIds }}\"\n        ],\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].State.Name\",\n        \"DesiredValues\": [\n          \"running\",\n          \"stopped\"\n        ]\n      },\n      \"maxAttempts\": 3,\n      \"timeoutSeconds\": 600,\n      \"onFailure\": \"step:CleanResources\",\n      \"nextStep\": \"getCloneInstance\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"getCloneInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"InstanceIds\": [\n          \"{{launchCloneInstance.InstanceIds}}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"InstanceId\",\n          \"Selector\": \"$.Reservations[0].Instances[0].InstanceId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"availabilityZone\",\n          \"Selector\": \"$.Reservations[0].Instances[0].Placement.AvailabilityZone\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"RootVolId\",\n          \"Selector\": \"$.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"rootDeviceName\",\n          \"Selector\": \"$.Reservations[0].Instances[0].RootDeviceName\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"checkIfSnapshotIdProvided\",\n      \"action\": \"aws:branch\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"ListSnapshotByDate\",\n            \"Variable\": \"{{SnapshotId}}\",\n            \"StringEquals\": \"\"\n          },\n          {\n            \"NextStep\": \"createNewRootVolumeFromSnapshot\",\n            \"Variable\": \"{{SnapshotId}}\",\n            \"StartsWith\": \"snap-\"\n          }\n        ]\n      },\n      \"description\": \"Check if we have to restore from a custom Snapshot-ID\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"ListSnapshotByDate\",\n      \"action\": \"aws:executeScript\",\n      \"inputs\": {\n        \"Runtime\": \"python3.7\",\n        \"Handler\": \"ListSnapshotByDate\",\n        \"Script\": \"import boto3\\nimport json\\nimport datetime\\nfrom datetime import datetime\\ndef ListSnapshotByDate(events, context):\\n                  volId= events[\\\"VolumeId\\\"]\\n                  objList = [ ]\\n                  startDate = events[\\\"StartDate\\\"]\\n                  endDate = events[\\\"EndDate\\\"]\\n                  startDate += \\\"T00:00:00+00:00\\\"\\n                  endDate += \\\"T23:59:00+00:00\\\" \\n                  skipSnapshotsBy = events[\\\"skipSnapshotsBy\\\"]\\n                  startDateDatetimeObj = datetime.strptime(startDate, '%Y/%m/%dT%H:%M:%S%z')\\n                  endDateDatetimeObj =  datetime.strptime(endDate, '%Y/%m/%dT%H:%M:%S%z')\\n                  checkInstanceStatus = events[\\\"CheckInstanceStatus\\\"]\\n                  totalSnapshotsToLookFor = events[\\\"TotalSnapshotsToLook\\\"]\\n                  if totalSnapshotsToLookFor == '':\\n                     totalSnapshotsToLookFor= 10000\\n                  else: \\n                    totalSnapshotsToLookFor = int(totalSnapshotsToLookFor)\\n                  client = boto3.client('ec2')\\n                  cwClient = boto3.client('cloudwatch')\\n                  response = client.describe_snapshots(\\n                            Filters=[\\n                                {\\n                                    'Name': 'volume-id',\\n                                    'Values': [\\n                                        volId,\\n                                    ]\\n                                },\\n                                {\\n                                    'Name': 'status',\\n                                    'Values': [\\n                                        'completed',\\n                                    ]\\n                                }\\n                            ]\\n                          )\\n                  for snap in response['Snapshots']:\\n                            obj = {'SnapID':snap['SnapshotId'], 'Date':snap['StartTime']}\\n                            objList.append(obj)\\n                  objList = sorted(objList, key=lambda k: k['Date'], reverse=True)\\n\\n                  nonCorruptedSnapshots = []\\n                  for snap in objList:\\n                    snapshotId = (snap['SnapID'])\\n                    checkSnapStatus = client.describe_tags(\\n                                        Filters=[\\n                                            {\\n                                                'Name': 'resource-id',\\n                                                'Values': [\\n                                                    snapshotId,\\n                                                ]\\n                                            },\\n                                            {\\n                                                'Name': 'key',\\n                                                'Values': [\\n                                                    'corrupted',\\n                                                ]\\n                                            }\\n                                    ]\\n                                    \\n                                )\\n                    if checkSnapStatus['Tags']:\\n                        if checkSnapStatus['Tags'][0]['Value']=='yes':\\n                                continue\\n                        else:\\n                            nonCorruptedSnapshots.append(snap)\\n                    else:\\n                        nonCorruptedSnapshots.append(snap)\\n                  \\n                  objList = nonCorruptedSnapshots\\n                  \\n                  if checkInstanceStatus:\\n                            inputJson = [\\n                                          {\\n                                              \\\"Id\\\": \\\"e1\\\",\\n                                              \\\"Expression\\\": \\\"IF(m1>0, m1)\\\",\\n                                              \\\"Label\\\": \\\"Expression1\\\"\\n                                          },\\n                                          {\\n                                              \\\"Id\\\": \\\"m1\\\",\\n                                              \\\"MetricStat\\\": {\\n                                                  \\\"Metric\\\": {\\n                                                      \\\"Namespace\\\": \\\"AWS/EC2\\\",\\n                                                      \\\"MetricName\\\": \\\"StatusCheckFailed\\\",\\n                                                      \\\"Dimensions\\\": [\\n                                                          {\\n                                                              \\\"Name\\\": \\\"InstanceId\\\",\\n                                                              \\\"Value\\\": events[\\\"InstanceId\\\"]\\n                                                          }\\n                                                      ]\\n                                                  },\\n                                                  \\\"Period\\\": 3600,\\n                                                  \\\"Stat\\\": \\\"Average\\\",\\n                                                  \\\"Unit\\\": \\\"Count\\\"\\n                                              },\\n                                              \\\"ReturnData\\\": False\\n                                          }\\n                                          \\n                                      ]\\n                            instanceCheckFail = cwClient.get_metric_data(\\n                                              MetricDataQueries=inputJson,\\n                                              StartTime=startDateDatetimeObj,\\n                                              EndTime=endDateDatetimeObj,\\n                                              ScanBy='TimestampAscending'\\n                                          )\\n\\n                            statusFailTime = instanceCheckFail['MetricDataResults'][0]['Timestamps']\\n                            if statusFailTime:\\n                              endDateDatetimeObj = min(endDateDatetimeObj, statusFailTime[0])\\n\\n\\n\\n\\n                  testSnapshotIds = [] # This contains list of snapshots which will be tested.\\n                  leftOutSnapshotIds = [] # This contains list of snapshots which will be not be tested in further steps this time\\n                  finalSnapshotIds = [] # This contains all snapshots which are relevent\\n                  \\n                  if skipSnapshotsBy > '0':\\n                      skipSnapshotsBy = int(skipSnapshotsBy) +1\\n                      objList = objList[::skipSnapshotsBy]\\n\\n                  \\n                  for snap in objList:\\n                      snapDate =  (snap['Date'])\\n                      if snapDate >= startDateDatetimeObj and snapDate <= endDateDatetimeObj:\\n                        finalSnapshotIds.append(snap['SnapID'])\\n                  \\n                  if events['Platform'] == 'windows':\\n                      totalSnapshotsToLookFor = min(totalSnapshotsToLookFor, 2)\\n                      testSnapshotIds = finalSnapshotIds[0:totalSnapshotsToLookFor]\\n                      leftOutSnapshotIds = finalSnapshotIds[totalSnapshotsToLookFor:]\\n                  else:\\n                      totalSnapshotsToLookFor = min(totalSnapshotsToLookFor, 2) # min snapshots for linux is also 2 at this stage because instance status check takes around 5 min and 12 min is hard cord limit for ssm run script, so more than 2 can't be tested for any platform. \\n                      testSnapshotIds = finalSnapshotIds[0:totalSnapshotsToLookFor]\\n                      leftOutSnapshotIds = finalSnapshotIds[totalSnapshotsToLookFor:]\\n                  \\n                  return {'finalSnapshots': testSnapshotIds, 'leftOutSnapshotIds': leftOutSnapshotIds}\\n\",\n        \"InputPayload\": {\n          \"VolumeId\": \"{{ describeInstance.RootVolId}}\",\n          \"StartDate\": \"{{StartDate}}\",\n          \"EndDate\": \"{{EndDate}}\",\n          \"Platform\": \"{{describeInstance.Platform}}\",\n          \"CheckInstanceStatus\": \"{{LookForInstancetStatusCheck}}\",\n          \"TotalSnapshotsToLook\": \"{{TotalSnapshotsToLook}}\",\n          \"InstanceId\": \"{{ InstanceId }}\",\n          \"skipSnapshotsBy\": \"{{ skipSnapshotsBy }}\"\n        }\n      },\n      \"description\": \"This will give the list of snapshots which were created later or on same date given by user\",\n      \"nextStep\": \"findWorkingSnapshot\",\n      \"outputs\": [\n        {\n          \"Name\": \"finalSnapshots\",\n          \"Selector\": \"$.Payload.finalSnapshots\",\n          \"Type\": \"StringList\"\n        },\n        {\n          \"Name\": \"remainingSnapshotToBeCheckedInSameDateRange\",\n          \"Selector\": \"$.Payload.leftOutSnapshotIds\",\n          \"Type\": \"StringList\"\n        }\n      ],\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"createNewRootVolumeFromSnapshot\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"CreateVolume\",\n        \"AvailabilityZone\": \"{{getCloneInstance.availabilityZone }}\",\n        \"SnapshotId\": \"{{SnapshotId}}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"newRootVolumeId\",\n          \"Selector\": \"$.VolumeId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"nextStep\": \"stopInstance\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"stopInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"StopInstances\",\n        \"InstanceIds\": [\n          \"{{ launchCloneInstance.InstanceIds }}\"\n        ]\n      },\n      \"nextStep\": \"verifyVolumeAvailability\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"verifyVolumeAvailability\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"available\"\n        ],\n        \"VolumeIds\": [\n          \"{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}\"\n        ]\n      },\n      \"nextStep\": \"verifyInstanceStopped\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\",\n      \"maxAttempts\": 3\n    },\n    {\n      \"name\": \"verifyInstanceStopped\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"DesiredValues\": [\n          \"stopped\"\n        ],\n        \"Api\": \"DescribeInstances\",\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].State.Name\",\n        \"InstanceIds\": [\n          \"{{ launchCloneInstance.InstanceIds }}\"\n        ]\n      },\n      \"nextStep\": \"detachRootVolume\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"detachRootVolume\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DetachVolume\",\n        \"VolumeId\": \"{{ getCloneInstance.RootVolId}}\"\n      },\n      \"nextStep\": \"verifyRootVolumeDetached\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\",\n      \"maxAttempts\": 3,\n      \"timeoutSeconds\": 3\n    },\n    {\n      \"name\": \"verifyRootVolumeDetached\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"available\"\n        ],\n        \"VolumeIds\": [\n          \"{{getCloneInstance.RootVolId}}\"\n        ]\n      },\n      \"timeoutSeconds\": 30,\n      \"nextStep\": \"attachNewRootVolume\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\",\n      \"maxAttempts\": 3\n    },\n    {\n      \"name\": \"attachNewRootVolume\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"AttachVolume\",\n        \"Device\": \"{{ getCloneInstance.rootDeviceName }}\",\n        \"VolumeId\": \"{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}\",\n        \"InstanceId\": \"{{ launchCloneInstance.InstanceId }}\"\n      },\n      \"nextStep\": \"verifyNewRootVolumeAttached\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"verifyNewRootVolumeAttached\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"PropertySelector\": \"$.Volumes[0].Attachments[0].State\",\n        \"DesiredValues\": [\n          \"attached\"\n        ],\n        \"VolumeIds\": [\n          \"{{ createNewRootVolumeFromSnapshot.newRootVolumeId }}\"\n        ]\n      },\n      \"timeoutSeconds\": 30,\n      \"nextStep\": \"startInstance\",\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\",\n      \"maxAttempts\": 3\n    },\n    {\n      \"name\": \"startInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"StartInstances\",\n        \"InstanceIds\": [\n          \"{{ launchCloneInstance.InstanceIds }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"InstanceState\",\n          \"Selector\": \"$.StartingInstances[0].CurrentState.Name\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"nextStep\": \"InstanceStatusCheck\",\n      \"timeoutSeconds\": 180,\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"InstanceStatusCheck\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].State.Name\",\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"DesiredValues\": [\n          \"running\"\n        ],\n        \"InstanceIds\": \"{{launchCloneInstance.InstanceIds}}\"\n      },\n      \"nextStep\": \"InstanceHealthCheck\",\n      \"maxAttempts\": 3,\n      \"timeoutSeconds\": 300,\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"InstanceHealthCheck\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"inputs\": {\n        \"Api\": \"DescribeInstanceStatus\",\n        \"PropertySelector\": \"$.InstanceStatuses[0].InstanceStatus.Details[0].Status\",\n        \"DesiredValues\": [\n          \"passed\"\n        ],\n        \"Service\": \"ec2\",\n        \"InstanceIds\": \"{{launchCloneInstance.InstanceIds}}\"\n      },\n      \"description\": \"Check if both System status checks and Instance status checks gets passed.\",\n      \"onFailure\": \"step:CleanResources\",\n      \"timeoutSeconds\": 420,\n      \"nextStep\": \"InstanceRecovery\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"findWorkingSnapshot\",\n      \"action\": \"aws:executeScript\",\n      \"inputs\": {\n        \"Runtime\": \"python3.6\",\n        \"Handler\": \"findWorkingSnapshot\",\n        \"Script\": \"import json\\nimport boto3\\nimport time\\nimport botocore\\nimport botocore.exceptions\\nimport sys\\ndef findWorkingSnapshot(event, context):\\n    client = boto3.client(\\n        'ec2'\\n    )\\n    snapshots= event['Snapshots']\\n    workingSnapFound = False\\n    workingSnap =''\\n    for snap in snapshots:\\n        checkSnapStatus = client.describe_tags(\\n                Filters=[\\n                    {\\n                        'Name': 'resource-id',\\n                        'Values': [\\n                            snap,\\n                        ]\\n                    },\\n                    {\\n                        'Name': 'key',\\n                        'Values': [\\n                            'corrupted',\\n                        ]\\n                    }\\n                ]\\n                \\n            )\\n        \\n        if checkSnapStatus['Tags']:\\n            if checkSnapStatus['Tags'][0]['Value']=='yes':\\n                continue\\n            elif checkSnapStatus['Tags'][0]['Value']=='no':\\n                workingSnapFound = True\\n                workingSnap = snap\\n                break\\n        \\n        volumeId = ''\\n        \\n        try:\\n            response = client.create_volume(\\n                AvailabilityZone=event['AvailabilityZone'],\\n                SnapshotId=snap)\\n            \\n            if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                volumeId= response['VolumeId']\\n                print('***volume:', volumeId)\\n            \\n            client.get_waiter('volume_available').wait(\\n                VolumeIds=[volumeId],\\n                WaiterConfig={\\n                    'Delay': 10,\\n                    'MaxAttempts': 12\\n                \\n                }\\n            )\\n            print('***Success!! volume:', volumeId, 'created...')\\n            \\n            \\n                \\n                    \\n        except Exception as e:\\n                print('***Failed to create the volume...')\\n                print(type(e), ':', e)\\n                continue\\n            \\n        \\n        if volumeId:\\n            try:\\n                stopInstance = client.stop_instances(\\n                    InstanceIds=[\\n                            event['InstanceId'][0]\\n                                ]\\n                )\\n                \\n                if stopInstance['ResponseMetadata']['HTTPStatusCode']== 200:\\n                        client.get_waiter('instance_stopped').wait(\\n                        InstanceIds=[\\n                            event['InstanceId'][0]\\n                                ],\\n                    \\n                        WaiterConfig={\\n                            'Delay': 10,\\n                            'MaxAttempts': 40\\n                            }\\n                    )\\n                        print (\\\"Instance is stopped\\\")\\n                \\n        \\n            except Exception as e:\\n                print('***Failed to stop the instance...')\\n                print(type(e), ':', e)\\n                continue\\n        \\n        try:\\n            \\n            describeInstance = client.describe_instances(\\n                                InstanceIds=[\\n                                    event['InstanceId'][0],\\n                                ]\\n                                )\\n            rootVolId = describeInstance['Reservations'][0]['Instances'][0]['BlockDeviceMappings'][0]['Ebs']['VolumeId']\\n\\n            deviceName = describeInstance['Reservations'][0]['Instances'][0]['BlockDeviceMappings'][0]['DeviceName']\\n\\n            \\n            if deviceName == event['DeviceId'] and rootVolId.startswith(\\\"vol\\\"):\\n                    response = client.detach_volume(\\n                                VolumeId= rootVolId )\\n                    if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                        print( \\\"***Success**\\\" + \\\"detaching root volume\\\")\\n                        client.get_waiter('volume_available').wait(\\n                                VolumeIds=[\\n                                    rootVolId\\n                                        ],\\n                                \\n                                WaiterConfig={\\n                                    'Delay': 10,\\n                                    'MaxAttempts':12\\n                                    }\\n                            )\\n                        \\n                        VolumeStatus = client.describe_volumes(\\n                                            VolumeIds=[rootVolId]\\n                        )\\n                        \\n                        if VolumeStatus['Volumes'][0]['State'] == 'available':\\n                            print (\\\"Volume detached\\\")\\n                        else:\\n                            print (\\\"Volume Not Detached\\\")\\n                \\n                \\n        except Exception as e:\\n                print('***Failed to detached the volume')\\n                print(type(e), ':', e)\\n                continue\\n        \\n        \\n        try:\\n            response = client.attach_volume(\\n                        Device=event['DeviceId'],\\n                        InstanceId=\\n                            event['InstanceId'][0]\\n                                ,\\n                        VolumeId=volumeId\\n                        )\\n            \\n            if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                \\n                print( \\\"***Success***\\\" + \\\"attaching root volume\\\")\\n                client.get_waiter('volume_in_use').wait(\\n                        VolumeIds=[\\n                                volumeId\\n                                ],\\n                        \\n                        WaiterConfig={\\n                            'Delay': 10,\\n                            'MaxAttempts':20\\n                            }\\n                    )\\n                VolumeStatus = client.describe_volumes(\\n                                    VolumeIds=[volumeId]\\n                )\\n                if VolumeStatus['Volumes'][0]['Attachments'][0]['State'] == 'attached':\\n                    print (\\\"Volume is attached\\\")\\n                \\n        \\n                \\n        except Exception as e:\\n                print('***Failed to attach the volume')\\n                print(type(e), ':', e)\\n                continue    \\n                \\n        try:\\n            response = client.start_instances(\\n                    InstanceIds=[event['InstanceId'][0]]\\n                        )\\n            \\n            if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                        client.get_waiter('instance_running').wait(\\n                        InstanceIds=[\\n                            event['InstanceId'][0]\\n                                ],\\n                    \\n                        WaiterConfig={\\n                            'Delay': 10,\\n                            'MaxAttempts':30\\n                            }\\n                            )\\n                        \\n                        client.get_waiter('instance_status_ok').wait(\\n                            InstanceIds=[\\n                            event['InstanceId'][0]\\n                                ],\\n                    \\n                        WaiterConfig={\\n                            'Delay': 10,\\n                            'MaxAttempts':26\\n                            }\\n                            \\n                            )\\n                        instanceStatus = client.describe_instance_status(\\n                                        InstanceIds=[\\n                                            event['InstanceId'][0]\\n                                                    ]\\n                                    )\\n                        \\n                        \\n                        if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok' and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':\\n                                print (\\\"Instance Passed\\\")\\n                                workingSnap = snap\\n                                workingSnapFound = True\\n                                client.create_tags(\\n    \\n                                        Resources=[\\n                                            snap,\\n                                        ],\\n                                        Tags=[\\n                                            {\\n                                                'Key': 'corrupted',\\n                                                'Value': 'no'\\n                                            },\\n                                        ]\\n                                    )\\n                                break\\n                                \\n                        else:\\n                            client.create_tags(\\n    \\n                                        Resources=[\\n                                            snap,\\n                                        ],\\n                                        Tags=[\\n                                            {\\n                                                'Key': 'corrupted',\\n                                                'Value': 'yes'\\n                                            },\\n                                        ]\\n                                    )\\n                            continue\\n                                \\n                        \\n        except botocore.exceptions.WaiterError  as waiterr:\\n            print(\\\"***Failed to reach out to the instance. Status check is getting timed out\\\")\\n            workingSnap = \\\"No working instance found, getting instance check timed out, please check is separately or look for further snapshots\\\"\\n            print(type(waiterr), ':', waiterr)\\n            client.create_tags(\\n    \\n                                        Resources=[\\n                                            snap,\\n                                        ],\\n                                        Tags=[\\n                                            {\\n                                                'Key': 'corrupted',\\n                                                'Value': 'yes'\\n                                            },\\n                                        ]\\n                                    )                \\n        except Exception as e:\\n                print('***Failed to Start the Instance')\\n                print(type(e), ':', e)\\n                client.create_tags(\\n    \\n                                        Resources=[\\n                                            snap,\\n                                        ],\\n                                        Tags=[\\n                                            {\\n                                                'Key': 'corrupted',\\n                                                'Value': 'yes'\\n                                            },\\n                                        ]\\n                                    )\\n                continue         \\n        \\n            \\n            \\n            \\n        \\n          \\n        \\n    return {'workingSnap':workingSnap}\\n\",\n        \"InputPayload\": {\n          \"Snapshots\": \"{{ListSnapshotByDate.finalSnapshots}}\",\n          \"DeviceId\": \"{{getCloneInstance.rootDeviceName}}\",\n          \"VolumeId\": \"{{getCloneInstance.RootVolId}}\",\n          \"InstanceId\": \"{{launchCloneInstance.InstanceIds}}\",\n          \"AvailabilityZone\": \"{{describeInstance.AvailabilityZone}}\"\n        }\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"workingSnapshot\",\n          \"Selector\": \"$.Payload.workingSnap\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"nextStep\": \"InstanceRecovery\",\n      \"timeoutSeconds\": 1200,\n      \"onFailure\": \"step:CleanResources\",\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"InstanceRecovery\",\n      \"action\": \"aws:executeScript\",\n      \"inputs\": {\n        \"Runtime\": \"python3.6\",\n        \"Handler\": \"InstanceRecovery\",\n        \"Script\": \"import json\\nimport boto3\\nimport sys\\nimport botocore\\nimport botocore.exceptions\\n\\ndef InstanceRecovery(event, context):\\n  client = boto3.client(\\n        'ec2'\\n    )\\n  inplaceSwap = event['InplaceSwap']\\n  snapshotId = event['SnapShotId']\\n  workingSnapshot = event['WorkingSnapshot']\\n  result = ''\\n  \\n  if inplaceSwap == True:\\n            \\n        if snapshotId =='':\\n\\n                if workingSnapshot:\\n                    volumeId = ''\\n            \\n                    try:\\n                        response = client.create_volume(\\n                            AvailabilityZone=event['AvailabilityZone'],\\n                            SnapshotId=workingSnapshot)\\n                        \\n                        if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                            volumeId= response['VolumeId']\\n                            print('***volume:', volumeId)\\n                        \\n                        client.get_waiter('volume_available').wait(\\n                            VolumeIds=[volumeId],\\n                            WaiterConfig={\\n                                'Delay': 10,\\n                                'MaxAttempts': 12\\n                            \\n                            }\\n                        )\\n                        print('***Success!! volume:', volumeId, 'created...')\\n                        \\n                        \\n                            \\n                                \\n                    except Exception as e:\\n                            print('***Failed to create the volume...')\\n                            print(type(e), ':', e)\\n                        \\n                    \\n                    if volumeId:\\n                        try:\\n                            stopInstance = client.stop_instances(\\n                                InstanceIds=[\\n                                        event['InstanceId']\\n                                            ]\\n                            )\\n                            \\n                            if stopInstance['ResponseMetadata']['HTTPStatusCode']== 200:\\n                                    client.get_waiter('instance_stopped').wait(\\n                                    InstanceIds=[\\n                                        event['InstanceId']\\n                                            ],\\n                                \\n                                    WaiterConfig={\\n                                        'Delay': 10,\\n                                        'MaxAttempts': 40\\n                                        }\\n                                )\\n                                    print (\\\"Instance is stopped\\\")\\n                            \\n                    \\n                        except Exception as e:\\n                            print('***Failed to stop the instance...')\\n                            print(type(e), ':', e)\\n                    \\n                    try:\\n                        response = client.detach_volume(\\n                                    VolumeId= event['VolumeId'] )\\n                        if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                            print( \\\"**Success**\\\" + \\\"detaching root volume\\\")\\n                            client.get_waiter('volume_available').wait(\\n                                    VolumeIds=[\\n                                        event['VolumeId']\\n                                            ],\\n                                    \\n                                    WaiterConfig={\\n                                        'Delay': 10,\\n                                        'MaxAttempts':12\\n                                        }\\n                                )\\n                            \\n                            volumeStatus = client.describe_volumes(\\n                                                VolumeIds=[event['VolumeId']]\\n                            )\\n                            \\n                            if volumeStatus['Volumes'][0]['State'] == 'available':\\n                                print (\\\"Volume detached\\\")\\n                            else:\\n                                print (\\\"Volume Not Detached\\\")\\n                            \\n                            \\n                    except Exception as e:\\n                            print('***Failed to detached the volume')\\n                            print(type(e), ':', e)\\n                            \\n                    \\n                    \\n                    try:\\n                        response = client.attach_volume(\\n                                    Device=event['DeviceId'],\\n                                    InstanceId=\\n                                        event['InstanceId']\\n                                            ,\\n                                    VolumeId=volumeId\\n                                    )\\n                        \\n                        if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                            \\n                            print( \\\"***\\\" + \\\"ataching root volume\\\")\\n                            client.get_waiter('volume_in_use').wait(\\n                                    VolumeIds=[\\n                                            volumeId\\n                                            ],\\n                                    \\n                                    WaiterConfig={\\n                                        'Delay': 10,\\n                                        'MaxAttempts':12\\n                                        }\\n                                )\\n                            volumeStatus = client.describe_volumes(\\n                                                VolumeIds=[volumeId]\\n                            )\\n                            if volumeStatus['Volumes'][0]['Attachments'][0]['State'] == 'attached':\\n                                print (\\\"Volume is attached\\\")\\n                            \\n                    \\n                            \\n                    except Exception as e:\\n                            print('***Failed to attach the volume')\\n                            print(type(e), ':', e)\\n                          \\n                            \\n                    try:\\n                        response = client.start_instances(\\n                                InstanceIds=[event['InstanceId']]\\n                                    )\\n                        \\n                        if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                                    client.get_waiter('instance_running').wait(\\n                                    InstanceIds=[\\n                                        event['InstanceId']\\n                                            ],\\n                                \\n                                    WaiterConfig={\\n                                        'Delay': 10,\\n                                        'MaxAttempts':30\\n                                        }\\n                                        )\\n                                    \\n                                    client.get_waiter('instance_status_ok').wait(\\n                                            InstanceIds=[\\n                                                event['InstanceId']\\n                                                    ],\\n                                        \\n                                            WaiterConfig={\\n                                                'Delay': 10,\\n                                                'MaxAttempts':40\\n                                                }\\n                                                )\\n                                    instanceStatus = client.describe_instance_status(\\n                                                    InstanceIds=[\\n                                                        event['InstanceId']\\n                                                                ]\\n                                                )\\n                                    \\n                                    \\n                                    if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok' and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':\\n                                            print (\\\"Instance Passed\\\")\\n                                            result += \\\"Instance status Passed and inplace swap is done\\\"\\n                                            \\n                                            \\n                                    else:\\n                                        print (\\\"Instance status failed\\\")\\n                                        result += \\\"Instance status failed\\\"\\n                                            \\n                                    \\n                    except botocore.exceptions.WaiterError  as waiterr:\\n                            print(\\\"***Failed to reach out to the instance. Status check is getting timed out\\\")\\n                            print(type(waiterr), ':', waiterr)  \\n                            result += \\\"Instance status check Timed out\\\"            \\n                    except Exception as e:\\n                            print('***Failed to Start the Instance')\\n                            print(type(e), ':', e)\\n                            result += \\\"Instance status failed\\\"      \\n            \\n                         \\n                else:\\n                         print (\\\"No working snapshot is available\\\")\\n                         result += \\\"No working snapshot is available\\\"\\n                 \\n                \\n            \\n        else:\\n                \\n                        volumeId = ''\\n        \\n                        try:\\n                            response = client.create_volume(\\n                                AvailabilityZone=event['AvailabilityZone'],\\n                                SnapshotId=snapshotId)\\n                            \\n                            if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                                volumeId= response['VolumeId']\\n                                print('***volume:', volumeId)\\n                            \\n                            client.get_waiter('volume_available').wait(\\n                                VolumeIds=[volumeId],\\n                                WaiterConfig={\\n                                    'Delay': 10,\\n                                    'MaxAttempts': 12\\n                                \\n                                }\\n                            )\\n                            print('***Success!! volume:', volumeId, 'created...')\\n                            \\n                            \\n                                \\n                                    \\n                        except Exception as e:\\n                                print('***Failed to create the volume...')\\n                                print(type(e), ':', e)\\n                                \\n                            \\n                        \\n                        if volumeId:\\n                            try:\\n                                stopInstance = client.stop_instances(\\n                                    InstanceIds=[\\n                                            event['InstanceId']\\n                                                ]\\n                                )\\n                                \\n                                if stopInstance['ResponseMetadata']['HTTPStatusCode']== 200:\\n                                        client.get_waiter('instance_stopped').wait(\\n                                        InstanceIds=[\\n                                            event['InstanceId']\\n                                                ],\\n                                    \\n                                        WaiterConfig={\\n                                            'Delay': 10,\\n                                            'MaxAttempts': 30\\n                                            }\\n                                    )\\n                                        print (\\\"Instance is stopped\\\")\\n                                \\n                        \\n                            except Exception as e:\\n                                print('***Failed to stop the instance...')\\n                                print(type(e), ':', e)\\n                            \\n                        \\n                        try:\\n                            response = client.detach_volume(\\n                                        VolumeId= event['VolumeId'] )\\n                            if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                                print( \\\"***\\\" + \\\"detaching root volume\\\")\\n                                client.get_waiter('volume_available').wait(\\n                                        VolumeIds=[\\n                                            event['VolumeId']\\n                                                ],\\n                                        \\n                                        WaiterConfig={\\n                                            'Delay': 10,\\n                                            'MaxAttempts':12\\n                                            }\\n                                    )\\n                                \\n                                volumeStatus = client.describe_volumes(\\n                                                    VolumeIds=[event['VolumeId']]\\n                                )\\n                                \\n                                if volumeStatus['Volumes'][0]['State'] == 'available':\\n                                    print (\\\"Volume detached\\\")\\n                                else:\\n                                    print (\\\"Volume Not Detached\\\")\\n                                \\n                                \\n                        except Exception as e:\\n                                print('***Failed to detached the volume')\\n                                print(type(e), ':', e)\\n                                \\n                        \\n                        \\n                        try:\\n                            response = client.attach_volume(\\n                                        Device=event['DeviceId'],\\n                                        InstanceId=\\n                                            event['InstanceId']\\n                                                ,\\n                                        VolumeId=volumeId\\n                                        )\\n                            \\n                            if response['ResponseMetadata']['HTTPStatusCode'] == 200:\\n                                \\n                                print( \\\"**\\\" + \\\"ataching root volume\\\")\\n                                client.get_waiter('volume_in_use').wait(\\n                                        VolumeIds=[\\n                                                volumeId\\n                                                ],\\n                                        \\n                                        WaiterConfig={\\n                                            'Delay': 10,\\n                                            'MaxAttempts':6\\n                                            }\\n                                    )\\n                                volumeStatus = client.describe_volumes(\\n                                                    VolumeIds=[volumeId]\\n                                )\\n                                if volumeStatus['Volumes'][0]['Attachments'][0]['State'] == 'attached':\\n                                    print (\\\"Volume is attached\\\")\\n                                \\n                        \\n                                \\n                        except Exception as e:\\n                                print('***Failed to attach the volume')\\n                                print(type(e), ':', e)\\n                                   \\n                                \\n                        try:\\n                            response = client.start_instances(\\n                                    InstanceIds=[event['InstanceId']]\\n                                        )\\n                            \\n                            if response['ResponseMetadata']['HTTPStatusCode']== 200:\\n                                        client.get_waiter('instance_running').wait(\\n                                        InstanceIds=[\\n                                            event['InstanceId']\\n                                                ],\\n                                    \\n                                        WaiterConfig={\\n                                            'Delay': 10,\\n                                            'MaxAttempts':30\\n                                            }\\n                                            )\\n                                        print (\\\"Instance is running\\\")\\n                                        client.get_waiter('instance_status_ok').wait(\\n                                        InstanceIds=[\\n                                            event['InstanceId']\\n                                                ],\\n                                    \\n                                        WaiterConfig={\\n                                            'Delay': 10,\\n                                            'MaxAttempts':40\\n                                            }\\n                                            )\\n                                        instanceStatus = client.describe_instance_status(\\n                                                        InstanceIds=[\\n                                                            event['InstanceId']\\n                                                                    ]\\n                                                    )\\n                                        \\n                                        \\n                                        if instanceStatus['InstanceStatuses'][0]['InstanceStatus']['Status']=='ok' and instanceStatus['InstanceStatuses'][0]['SystemStatus']['Status']=='ok':\\n                                                print (\\\"Instance Passed and inplace swap is done\\\")\\n                                                result += \\\"Instance Passed and inplace swap is done\\\"\\n                                                \\n                                                \\n                                        else:\\n                                            print (\\\"Instance status failed\\\")\\n                                            result += \\\"Instance status failed\\\"\\n                                                \\n                                        \\n                        except botocore.exceptions.WaiterError  as waiterr:\\n                            print(\\\"***Failed to reach out to the instance. Status check is getting timed out\\\")\\n                            print(type(waiterr), ':', waiterr)\\n                            result += \\\"Instance status check Timed out\\\"               \\n                        except Exception as e:\\n                                print('***Failed to Start the Instance')\\n                                print(type(e), ':', e)\\n                                result += \\\"Instance status failed\\\"\\n        \\n        try:\\n            response = client.terminate_instances(\\n                            InstanceIds=[\\n                                event['CloneInstanceId'][0]])\\n        except Exception as terminateFailed:\\n                print('***Instance Termination failed')\\n                print(type(terminateFailed), ':', terminateFailed)\\n\\n         \\n  else:\\n                if snapshotId:\\n                    print (\\\"working Instance\\\", event['CloneInstanceId'][0])\\n                    result += \\\"working Instance\\\" + event['CloneInstanceId'][0]\\n                    \\n                else:\\n                    if workingSnapshot:\\n                        print (\\\"working Instance\\\", event['CloneInstanceId'][0])\\n                        result += \\\"working Instance\\\" + event['CloneInstanceId'][0]\\n                    else:\\n                        print (\\\"Instance recovery cannot happen as it does not have working snapshot\\\")\\n                        result += \\\"Instance recovery cannot happen as it does not have working snapshot\\\"\\n                \\n    \\n        \\n  return {'result':result}\\n\",\n        \"InputPayload\": {\n          \"InplaceSwap\": \"{{InplaceSwap}}\",\n          \"SnapShotId\": \"{{SnapshotId}}\",\n          \"CloneInstanceId\": \"{{launchCloneInstance.InstanceIds}}\",\n          \"DeviceId\": \"{{getCloneInstance.rootDeviceName}}\",\n          \"AvailabilityZone\": \"{{describeInstance.AvailabilityZone}}\",\n          \"VolumeId\": \"{{describeInstance.RootVolId}}\",\n          \"InstanceId\": \"{{ InstanceId }}\",\n          \"WorkingSnapshot\": \"{{ findWorkingSnapshot.workingSnapshot}}\"\n        }\n      },\n      \"onFailure\": \"step:CleanResources\",\n      \"outputs\": [\n        {\n          \"Name\": \"result\",\n          \"Selector\": \"$.Payload.result\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"onCancel\": \"step:CleanResources\"\n    },\n    {\n      \"name\": \"CleanResources\",\n      \"action\": \"aws:executeScript\",\n      \"description\": \"This will clean all the additional resources which were created by SSM document during execution.\",\n      \"inputs\": {\n        \"Runtime\": \"python3.6\",\n        \"Handler\": \"CleanResources\",\n        \"Script\": \"import json\\nimport boto3\\ndef CleanResources(events, context):\\n  \\n  client = boto3.client(\\n        'ec2'\\n    )\\n  \\n  try:\\n    client.delete_tags(\\n    Resources = [\\n        events['InstanceId']\\n    ],\\n    Tags = [\\n        {\\n            'Key': 'SSMExecutionStatusOn',\\n            'Value': 'Yes'\\n        }\\n    ]\\n  )\\n    if events['ImageId'].startswith(\\\"ami\\\"):\\n      checkImageStatus =  client.describe_images(\\n        Filters=[\\n            {\\n                'Name': 'name',\\n                'Values': [\\n                    events['TagValue']\\n                ]\\n            }\\n        ],\\n        ImageIds=[\\n            events['ImageId']\\n        ]\\n    )\\n      if checkImageStatus['Images'] !='':\\n                try:\\n                  response = client.deregister_image(\\n                             ImageId=events['ImageId']\\n                             )\\n\\n                except Exception as e:\\n                  print('***Failed to deregister the image.')\\n                  print(type(e), ':', e)\\n\\n  except Exception as e:\\n                print('***Failed to delete the tags')\\n                print(type(e), ':', e)\\n  \\n  if events['CloneInstanceId'][0].startswith(\\\"i-\\\"):\\n    if events['CloneInstanceId'][0] and events['InplaceSwap'] :\\n          try:\\n            client.terminate_instances(\\n                                InstanceIds=[\\n                                    events['CloneInstanceId'][0]])\\n          except Exception as e:\\n                  print('***Failed to terminate the instance.')\\n                  print(type(e), ':', e)\\n  return 0\\n\",\n        \"InputPayload\": {\n          \"InstanceId\": \"{{InstanceId }}\",\n          \"ImageId\": \"{{ describeOriginalInstanceImage.ImageId }}\",\n          \"CloneInstanceId\": \"{{launchCloneInstance.InstanceIds }}\",\n          \"TagValue\": \"AWSSupport_RestoreInstanceFromSnapshot-{{ automation:EXECUTION_ID }}\",\n          \"InplaceSwap\": \"{{InplaceSwap}}\"\n        }\n      }\n    }\n  ]\n}",
  "CreatedDate": "2021-10-28T15:43:10.964Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "1",
  "Name": "AWSSupport-RestoreEC2InstanceFromSnapshot",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "5116666a-912d-42f9-8802-dc0b119a53a8",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 68365,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-04-05T07:13:32.1793924+00:00"
}
