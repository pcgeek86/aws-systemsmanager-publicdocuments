{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\" : \"## Id\\nAWSResilienceHub-ChangeLambdaConcurrencyLimitSOP_2020-10-26\\n\\n## Intent\\nChange reserved concurrent executions limit of a Lambda function\\n\\n## Type\\nSOP\\n\\n## Risk\\nMedium\\n\\n## Requirements\\n  * Lambda Function\\n\\n## Permissions required for AutomationAssumeRole\\n  * servicequotas:ListAWSDefaultServiceQuotas\\n  * servicequotas:ListServiceQuotas\\n  * servicequotas:GetAWSDefaultServiceQuota\\n  * lambda:PutFunctionConcurrency\\n  * lambda:ListFunctions\\n  * lambda:GetFunctionConcurrency\\n  * lambda:PutFunctionConcurrency\\n\\n##### To log output to CloudWatch\\n  * logs:CreateLogStream\\n  * logs:PutLogEvents\\n  * logs:DescribeLogGroups\\n  * logs:DescribeLogStreams\\n\\n## Cancellation behavior\\nFail\\n\\n## Inputs\\n### (Required) AutomationAssumeRole\\n  * type: String\\n  * description: ARN of the IAM role with permissions listed above\\n\\n### (Required) LambdaARN\\n  * type: String\\n  * description: The ARN of the Lambda function\\n\\n### (Optional) NewReservedConcurrentExecutions\\n  * type: Integer\\n  * description: New reserved concurrent executions limit value\\n  * default: 0\\n\\n## Details\\nThe document checks the amount of available concurrent executions and sets the specified value for the\\nspecified Lambda if it's possible.\\n\\n## Steps executed in normal flow\\n  * RecordStartTime\\n  * GetConcurrentExecutionsQuota\\n  * CalculateTotalReservedConcurrencyOfExistingLambdas\\n  * CheckFeasibility\\n  * SetReservedConcurrentExecutions\\n  * OutputRecoveryTime\\n\\n## Outputs\\n### GetConcurrentExecutionsQuota.ConcurrentExecutionsQuota\\n  * type: Integer\\n  * description: Service quota for account\\n\\n### CalculateTotalReservedConcurrencyOfExistingLambdas.TotalReservedConcurrency\\n  * type: Integer\\n  * description: Amount of reserved concurrency executions for all existing Lambda functions\\n\\n### CheckFeasibility.MaximumPossibleReservedConcurrency\\n  * type: Integer\\n  * description: Number of available reserved concurrency executions\\n\\n### SetReservedConcurrentExecutions.ReservedConcurrencyLeft\\n  * type: Integer\\n  * description: Number of available reserved concurrency executions after update\\n\\n### SetReservedConcurrentExecutions.NewReservedConcurrencyValue\\n  * type: Integer\\n  * description: Updated reserved concurrency executions value for the specified Lambda function\\n\\n### OutputRecoveryTime.RecoveryTime\\n  * type: Integer\\n  * description: Execution time in seconds\",\n  \"schemaVersion\" : \"0.3\",\n  \"assumeRole\" : \"{{AutomationAssumeRole}}\",\n  \"outputs\" : [ \"GetConcurrentExecutionsQuota.ConcurrentExecutionsQuota\", \"CalculateTotalReservedConcurrencyOfExistingLambdas.TotalReservedConcurrency\", \"CheckFeasibility.MaximumPossibleReservedConcurrency\", \"SetReservedConcurrentExecutions.ReservedConcurrencyLeft\", \"SetReservedConcurrentExecutions.NewReservedConcurrencyValue\", \"OutputRecoveryTime.RecoveryTime\" ],\n  \"parameters\" : {\n    \"LambdaARN\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) The ARN of the Lambda function.\"\n    },\n    \"NewReservedConcurrentExecutions\" : {\n      \"type\" : \"Integer\",\n      \"description\" : \"(Optional) New reserved concurrent executions\",\n      \"default\" : 0\n    },\n    \"AutomationAssumeRole\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) The ARN of the role that allows Automation to perform the actions on your behalf.\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"RecordStartTime\",\n    \"description\" : \"Start recording execution time\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"StartTime\",\n      \"Selector\" : \"$.Payload\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"start_time\",\n      \"Script\" : \"import boto3\\nimport logging\\nfrom datetime import datetime, timezone\\nimport time\\n\\nfrom botocore.exceptions import ClientError\\nfrom dateutil import parser\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\n\\n\\ndef start_time(events, context):\\n    return datetime.now(timezone.utc).isoformat()\"\n    }\n  }, {\n    \"name\" : \"GetConcurrentExecutionsQuota\",\n    \"description\" : \"Get the current or default quota for AWS Lambda Service\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"get_concurrent_execution_quota\",\n      \"Script\" : \"import time\\nfrom datetime import datetime\\n\\nimport boto3\\nimport logging\\n\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\nCONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'\\nMINIMUM_UNRESERVED_CONCURRENCY = 100\\n\\n\\n\\ndef get_concurrent_execution_quota(events, context):\\n    try:\\n        config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n        quotas_client = boto3.client('service-quotas', config=config)\\n        paginator = quotas_client.get_paginator('list_service_quotas')\\n        pages = paginator.paginate(ServiceCode='lambda')\\n        concurrent_execution_quota = None\\n        for page in pages:\\n            quotas = page.get('Quotas')\\n            for quota in quotas:\\n                quota_code = quota.get('QuotaCode')\\n                if quota_code == CONCURRENT_EXECUTION_QUOTA_CODE:\\n                    concurrent_execution_quota = quota.get('Value')\\n                    break\\n        if not concurrent_execution_quota:\\n            default_quota_info = quotas_client.get_aws_default_service_quota(\\n                ServiceCode='lambda',\\n                QuotaCode=CONCURRENT_EXECUTION_QUOTA_CODE\\n            )\\n            concurrent_execution_quota = default_quota_info.get('Quota').get('Value')\\n        return {'ConcurrentExecutionsQuota': int(concurrent_execution_quota)}\\n    except Exception as e:\\n        logger.error(f'Loading ConcurrentExecutionsQuota for Lambda failed with error: {e}')\\n        raise\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"ConcurrentExecutionsQuota\",\n      \"Selector\" : \"$.Payload.ConcurrentExecutionsQuota\",\n      \"Type\" : \"Integer\"\n    } ]\n  }, {\n    \"name\" : \"CalculateTotalReservedConcurrencyOfExistingLambdas\",\n    \"description\" : \"Calculate total reserved concurrency by summing up values from all Lambda functions\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"calculate_total_reserved_concurrency\",\n      \"InputPayload\" : {\n        \"LambdaARN\" : \"{{ LambdaARN }}\"\n      },\n      \"Script\" : \"import time\\nfrom datetime import datetime\\n\\nimport boto3\\nimport logging\\n\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\nCONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'\\nMINIMUM_UNRESERVED_CONCURRENCY = 100\\n\\n\\n\\ndef calculate_total_reserved_concurrency(events, context):\\n    try:\\n        config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n        lambda_client = boto3.client('lambda', config=config)\\n        lambda_arn = events.get('LambdaARN')\\n        paginator = lambda_client.get_paginator('list_functions')\\n        pages = paginator.paginate()\\n        total_reserved_concurrency = 0\\n        for page in pages:\\n            functions = page.get('Functions')\\n            for lambda_function in functions:\\n                function_name: str = lambda_function.get('FunctionName')\\n                function_arn: str = lambda_function.get('FunctionArn')\\n                if lambda_arn != function_arn:\\n                    function_concurrency_info = lambda_client.get_function_concurrency(\\n                        FunctionName=function_name\\n                    )\\n                    function_concurrency = function_concurrency_info.get('ReservedConcurrentExecutions', 0)\\n                    total_reserved_concurrency += function_concurrency\\n        return {'TotalReservedConcurrency': total_reserved_concurrency}\\n    except Exception as e:\\n        logger.error(f'Calculating total reserved concurrency for all Lambda functions failed with error: {e}')\\n        raise\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"TotalReservedConcurrency\",\n      \"Selector\" : \"$.Payload.TotalReservedConcurrency\",\n      \"Type\" : \"Integer\"\n    } ]\n  }, {\n    \"name\" : \"CheckFeasibility\",\n    \"description\" : \"Checks if it's possible to set Lambda's reserved concurrency to `NewReservedConcurrentExecutions`\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"check_feasibility\",\n      \"InputPayload\" : {\n        \"ConcurrentExecutionsQuota\" : \"{{ GetConcurrentExecutionsQuota.ConcurrentExecutionsQuota }}\",\n        \"TotalReservedConcurrency\" : \"{{ CalculateTotalReservedConcurrencyOfExistingLambdas.TotalReservedConcurrency }}\",\n        \"NewReservedConcurrentExecutions\" : \"{{ NewReservedConcurrentExecutions }}\"\n      },\n      \"Script\" : \"import time\\nfrom datetime import datetime\\n\\nimport boto3\\nimport logging\\n\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\nCONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'\\nMINIMUM_UNRESERVED_CONCURRENCY = 100\\n\\n\\n\\ndef check_feasibility(events: dict, context):\\n    try:\\n        concurrent_executions_quota = events.get('ConcurrentExecutionsQuota')\\n        total_reserved_concurrency = events.get('TotalReservedConcurrency')\\n        new_reserved_concurrent_executions = events.get('NewReservedConcurrentExecutions')\\n        maximum_possible_reserved_concurrency = (concurrent_executions_quota\\n                                                 - total_reserved_concurrency\\n                                                 - new_reserved_concurrent_executions\\n                                                 - MINIMUM_UNRESERVED_CONCURRENCY)\\n        can_set_reserved_concurrency = maximum_possible_reserved_concurrency > 0\\n        if not can_set_reserved_concurrency:\\n            raise Exception(\\n                f'You can reserve up to the Unreserved account concurrency value that is shown, minus 100 for functions'\\n                f' that don\\\\'t have reserved concurrency. There is only {maximum_possible_reserved_concurrency}'\\n                f'concurrent executions left')\\n        return {\\n            'CanSetReservedConcurrency': can_set_reserved_concurrency,\\n            'MaximumPossibleReservedConcurrency': maximum_possible_reserved_concurrency\\n        }\\n    except Exception as e:\\n        logger.error(f'Checking feasibility failed with error: {e}')\\n        raise\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"MaximumPossibleReservedConcurrency\",\n      \"Selector\" : \"$.Payload.MaximumPossibleReservedConcurrency\",\n      \"Type\" : \"Integer\"\n    }, {\n      \"Name\" : \"CanSetReservedConcurrency\",\n      \"Selector\" : \"$.Payload.CanSetReservedConcurrency\",\n      \"Type\" : \"Boolean\"\n    } ]\n  }, {\n    \"name\" : \"SetReservedConcurrentExecutions\",\n    \"description\" : \"Set new value for reserved concurrent executions\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"set_reserved_concurrent_executions\",\n      \"InputPayload\" : {\n        \"LambdaARN\" : \"{{ LambdaARN }}\",\n        \"NewReservedConcurrentExecutions\" : \"{{ NewReservedConcurrentExecutions }}\",\n        \"MaximumPossibleReservedConcurrency\" : \"{{ CheckFeasibility.MaximumPossibleReservedConcurrency }}\"\n      },\n      \"Script\" : \"import time\\nfrom datetime import datetime\\n\\nimport boto3\\nimport logging\\n\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\nCONCURRENT_EXECUTION_QUOTA_CODE = 'L-B99A9384'\\nMINIMUM_UNRESERVED_CONCURRENCY = 100\\n\\n\\n\\ndef set_reserved_concurrent_executions(events: dict, context):\\n    try:\\n        lambda_arn = events.get('LambdaARN')\\n        new_reserved_concurrent_executions = events.get('NewReservedConcurrentExecutions')\\n        maximum_possible_reserved_concurrency = events.get('MaximumPossibleReservedConcurrency')\\n        config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n        lambda_client = boto3.client('lambda', config=config)\\n        lambda_client.put_function_concurrency(\\n            FunctionName=lambda_arn,\\n            ReservedConcurrentExecutions=new_reserved_concurrent_executions\\n        )\\n        reserved_concurrency_left = maximum_possible_reserved_concurrency - new_reserved_concurrent_executions\\n        return {\\n            'ReservedConcurrencyLeft': reserved_concurrency_left,\\n            'NewReservedConcurrencyValue': new_reserved_concurrent_executions\\n        }\\n    except Exception as e:\\n        logger.error(f'Setting new value for reserved concurrent executions failed with error: {e}')\\n        raise\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"NewReservedConcurrencyValue\",\n      \"Selector\" : \"$.Payload.NewReservedConcurrencyValue\",\n      \"Type\" : \"Integer\"\n    }, {\n      \"Name\" : \"ReservedConcurrencyLeft\",\n      \"Selector\" : \"$.Payload.ReservedConcurrencyLeft\",\n      \"Type\" : \"Integer\"\n    } ]\n  }, {\n    \"name\" : \"OutputRecoveryTime\",\n    \"description\" : \"Calculate execution time\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"RecoveryTime\",\n      \"Selector\" : \"$.Payload\",\n      \"Type\" : \"Integer\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.7\",\n      \"Handler\" : \"recovery_time\",\n      \"Script\" : \"import boto3\\nimport logging\\nfrom datetime import datetime, timezone\\nimport time\\n\\nfrom botocore.exceptions import ClientError\\nfrom dateutil import parser\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\n\\n\\ndef recovery_time(events, context):\\n    return (datetime.now(timezone.utc) - parser.parse(events['StartTime'])).seconds\",\n      \"InputPayload\" : {\n        \"StartTime\" : \"{{ RecordStartTime.StartTime }}\"\n      }\n    }\n  } ]\n}",
  "CreatedDate": "2021-11-05T22:55:55.31Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "1",
  "Name": "AWSResilienceHub-ChangeLambdaConcurrencyLimitSOP_2020-10-26",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "da9b424c-6c77-410c-9d78-468ee1a9b7c5",
    "Metadata": {}
  },
  "ContentLength": 14980,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-02-16T07:11:27.6969988+00:00"
}
