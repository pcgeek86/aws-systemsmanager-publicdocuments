{
  "AttachmentsContent": [],
  "Content": "{\n  \"schemaVersion\" : \"2.2\",\n  \"description\" : \"Command Document Example JSON Template\",\n  \"parameters\" : {\n    \"Message\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Example\",\n      \"default\" : \"Hello World\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"action\" : \"aws:runPowerShellScript\",\n    \"name\" : \"example\",\n    \"inputs\" : {\n      \"runCommand\" : [ \"#4-19-2020 Version; fixed variable $computername issue. Conflicting with $HOSTNAME in some of the setconfig files.\\n#4-20-2020 Version ; Fixed data server installer pathing issue.\\n#6-4-2020 Added step to grab FFMPEG binaries\\n#6-11-2020 Added step to grab FFMPEG binaries for grids as well, cripes.\\n#Force TLS 1.2\\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\\n\\n#############################VARS##########################################\\n\\n#for logging purposes, grab the computer name\\n$computername = $env:computername\\n\\n#How long we're waiting after we stop services.\\n#We don't even use this anymore i think. relic of the past.\\n$TGRP_CHANGE_WAIT=180\\n#We *may* need the file server path which can be found below\\n#$UNC_FILE = \\\"C:\\\\Program Files\\\\Common Files\\\\Calabrio ONE\\\\Server\\\\config\\\\configPath.properties\\\"\\n\\n# RegionTag and RoleTag are used to determine ALB naming convention. Starting with a blank so we can test against it if the instance can \\n$RegionTag = \\\"\\\"\\n$RoleTag = \\\"\\\"\\n$KafkaConsumer = \\\"\\\"\\n$HOST_ADDRESS = Get-NetIPAddress -AddressFamily IPv4 -InterfaceIndex $(Get-NetAdapter | select -expand ifIndex) | select -expand IPAddress\\n$computername = $env:computername\\n#Redundant from setconfig.ps1, using $computername\\n#$HOSTNAME = $env:COMPUTERNAME\\n\\nif( ! ( Test-Path \\\"C:\\\\Temp\\\\Releases\\\" )) {\\n  echo \\\"Releases Temp directory doesn't exist. creating\\\" \\n  mkdir \\\"C:\\\\Temp\\\\Releases\\\"\\n}\\n\\nSet-Location -path   \\\"C:\\\\Temp\\\\Releases\\\"\\n#these 3 lines are to gather region data and instance ID data\\n$webclient = new-object net.webclient\\n$AWS_REGION = (irm http://169.254.169.254/latest/dynamic/instance-identity/document | % region)\\n$instanceid = $webclient.Downloadstring('http://169.254.169.254/latest/meta-data/instance-id')\\n$version_tag = Get-EC2Tag | ` Where-Object {$_.ResourceId -eq $instanceid -and $_.Key -eq 'DesiredC1Version'}\\n$SCC_VERSION = $version_tag.Value\\necho \\\"Desired SCC Version is $SCC_VERSION\\\"\\nstart-sleep -Seconds 5\\n$RegionTag =  Get-EC2Tag | ` Where-Object {$_.ResourceId -eq $instanceid -and $_.Key -eq 'RegionALB'}\\n$C1ENV = $RegionTag.Value\\necho \\\"$C1ENV is the value for RegionTag\\\"\\n$RoleTag = Get-EC2Tag | ` Where-Object {$_.ResourceId -eq $instanceid -and $_.Key -eq 'Role'}\\n$C1TYPE = $RoleTag.Value\\necho \\\"$C1TYPE is the value for RoleTag\\\"\\n$KafkaConsumer = Get-EC2Tag | ` Where-Object {$_.ResourceId -eq $instanceid -and $_.Key -eq 'KafkaConsumer'}\\necho $KafkaConsumer\\n$KafkaConsumerValue = $KafkaConsumer.Value\\n\\nif ( [string]::IsNullOrEmpty($RoleTag)) {\\n  echo \\\"RoleTag is empty, stop and fix tags in AWS\\\"\\n  exit\\n}\\n\\nif ( [string]::IsNullOrEmpty($RegionTag) -And $RoleTag.Value -eq \\\"web\\\") {\\n  echo \\\"RegionTag is empty and RoleTag is Web, this server will not drain properly, unable to contine, exiting...\\\"\\n  exit\\n}\\n\\nif ( [string]::IsNullOrEmpty($RegionTag) -And $RoleTag.Value -eq \\\"app\\\") {\\n  echo \\\"RegionTag is empty and RoleTag is App, this server will not drain properly, unable to contine, exiting...\\\"\\n  exit\\n}\\nif ( [string]::IsNullOrEmpty($KafkaConsumer) -And $RoleTag.Value -eq \\\"app\\\") {\\n  echo \\\"App Role detected, but Key KafkaConsumer isn't specified. Exiting.\\\"\\n  exit\\n}\\n$RELEASE_FILE=\\\"\\\"\\n$UNC_FILE = \\\"C:\\\\Program Files\\\\Common Files\\\\Calabrio ONE\\\\Server\\\\config\\\\configPath.properties\\\"\\n$FILES_DIR=\\\"Releases\\\"\\n\\n\\n$S3BUCKET = \\\"calabriocloudprodpatches\\\"\\n$BUILDPATH = \\\"C:\\\\temp\\\\\\\"\\n\\n# Set the log dir\\n$LOGS_DIR=\\\"C:\\\\Temp\\\"\\n\\n#echo \\\"LOGS_DIR is $LOGS_DIR\\\"\\n# Make sure log directory exists.\\nif( ! ( Test-Path \\\"$LOGS_DIR\\\\$SCC_VERSION\\\" )) {\\n  echo \\\"Logs directory doesn't exist, creating '$LOGS_DIR'\\\" \\n  $PRELOG+=\\\"Logs directory doesn't exist, creating '$LOGS_DIR'\\\\n\\\" \\n  $PRELOG+=\\\" `n\\\"\\n  mkdir \\\"$LOGS_DIR\\\\$SCC_VERSION\\\"\\n}\\n\\n$LOG_FILE=\\\"$LOGS_DIR\\\\$SCC_VERSION\\\\$C1ENV-$computername.log\\\"\\n\\n#############################MAIN##########################################\\n\\necho \\\"Region Tag is $C1ENV\\\" | tee -Append \\\"$LOG_FILE\\\"\\necho \\\"Role tag is $C1TYPE\\\" | tee -Append \\\"$LOG_FILE\\\"        \\n\\necho \\\"Staging Patch to c:\\\\temp\\\" | tee -Append \\\"$LOG_FILE\\\"\\necho \\\"Copy command is aws s3 cp s3://$S3BUCKET/$SCC_VERSION/$SCC_VERSION.zip .\\\" | tee -Append \\\"$LOG_FILE\\\"\\naws s3 cp s3://$S3BUCKET/$SCC_VERSION/$SCC_VERSION.zip .\\n#Make sure the Patch artifact file exists before proceeding.\\nif( ! ( Test-Path \\\"C:\\\\Temp\\\\Releases\\\\$SCC_VERSION.zip\\\" )) {\\n  echo \\\"Patch artifact zipfile missing. Path expected is s3://$S3BUCKET/$SCC_VERSION/$SCC_VERSION.zip. Exiting.\\\" | tee -Append \\\"$LOG_FILE\\\"\\n  exit\\n}\\n\\nWrite-Host \\\"Expanding latest patch\\\"\\n& \\\"C:\\\\Program Files\\\\7-Zip\\\\7z.exe\\\" x \\\"C:\\\\Temp\\\\Releases\\\\$SCC_VERSION.zip\\\" -o\\\"C:\\\\Temp\\\\Releases\\\\\\\" -r -y | tee -Append \\\"$LOG_FILE\\\"\\n\\necho \\\"Copying setconfig zip file directory from S3. Command is aws s3 cp s3://$S3BUCKET/ConfigManagement/$C1ENV.zip . \\\" | tee -Append \\\"$LOG_FILE\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/$C1ENV.zip . \\n\\n#Make sure the SetConfig download is successful. Stop if we're missing our config.\\nif( ! ( Test-Path \\\"C:\\\\Temp\\\\Releases\\\\$C1ENV.zip\\\" )) {\\n  echo \\\"Regionalized SetConfig Zip missing from $S3BUCKET. Path expected is s3://$S3BUCKET/ConfigManagement/$C1ENV.zip. Exiting.\\\" | tee -Append \\\"$LOG_FILE\\\" \\n}\\n\\nWrite-Host \\\"Expanding setconfig stuff over the latest patch\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\n& \\\"C:\\\\Program Files\\\\7-Zip\\\\7z.exe\\\" x \\\"C:\\\\Temp\\\\Releases\\\\$C1ENV.zip\\\" -o\\\"C:\\\\Temp\\\\Releases\\\\$SCC_VERSION\\\\\\\" -r -y | tee -Append \\\"$LOG_FILE\\\"\\n\\n\\nif( ! ( Test-Path \\\"C:\\\\Temp\\\\Releases\\\\$SCC_VERSION\\\" )) {\\n  echo \\\"Expected Version Folder doesn't exist at path C:\\\\Temp\\\\Releases\\\\$SCC_VERSION. Exiting.\\\" | tee -Append \\\"$LOG_FILE\\\" \\n  exit\\n}\\n\\n$FILES_PATH=\\\"$FILES_DIR\\\\$SCC_VERSION\\\\Program Files\\\"\\n\\necho \\\"Working on upgrading $computername\\\" | tee -Append \\\"$LOG_FILE\\\"\\n#start-sleep -Seconds 5\\n#echo \\\"Files Path: \\\\\\\\$FILE_SERVER\\\\$FILES_PATH\\\" | tee -Append \\\"$LOG_FILE\\\"\\n#start-sleep -Seconds 5\\necho \\\"Log File: '$LOG_FILE'\\\"\\nstart-sleep -Seconds 1\\nif ($RoleTag.Value -eq \\\"web\\\") {\\necho \\\"Web server detected\\\" | tee -Append \\\"$LOG_FILE\\\"\\necho \\\"$C1ENV is our environment prefix. Determining ALB names\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\n#currently isn't needed, but maybe will be later.\\n\\n#not currently used, a drain time from previous script\\n#append some variables that turn into your target group ALB names\\n$HTTP_TGRP = $C1ENV+'-http'\\n$HTTPS_TGRP = $C1ENV+'-https'\\n#echo \\\"HTTP Target Group is $HTTP_TGRP\\\" \\n#echo \\\"HTTPS Target Group is $HTTPS_TGRP\\\" \\n\\n#This drains it no matter what. \\n\\n#$TMP = & { aws elbv2 describe-target-groups --name \\\"$T_TGRP\\\" --region $AWS_REGION --output text }\\n$HTTPTMP = & { aws elbv2 describe-target-groups --name $HTTP_TGRP --region $AWS_REGION --output text } \\n$HTTPSTMP = & { aws elbv2 describe-target-groups --name $HTTPS_TGRP --region $AWS_REGION --output text } \\n\\n$HTTPTMP_PARTS = $HTTPTMP.split(\\\"\\t\\\") # Results delimited by tabs\\n$HTTPSTMP_PARTS = $HTTPSTMP.split(\\\"\\t\\\") # Results delimited by tabs\\n#echo $HTTPTMP_PARTS\\n#echo $HTTPSTMP_PARTS\\n$HTTP_ARN = $HTTPTMP_PARTS[9]\\n$HTTPS_ARN = $HTTPSTMP_PARTS[9]\\n\\n#echo \\\"HTTP_ARN is $HTTP_ARN\\\"\\n#echo \\\"HTTPS_ARN is $HTTPS_ARN\\\"\\necho \\\"waiting $TGRP_CHANGE_WAIT seconds for WEB server to to drain\\\" | tee -Append \\\"$LOG_FILE\\\"\\naws elbv2 deregister-targets --target-group-arn $HTTP_ARN --targets Id=$instanceid --region $AWS_REGION --output text\\naws elbv2 deregister-targets --target-group-arn $HTTPS_ARN --targets Id=$instanceid --region $AWS_REGION --output text\\necho \\\"drain command sent, starting 300 second wait\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 240 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 180 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 120 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 60 seconds for the server to drain\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\n}\\n\\nif ($RoleTag.Value -eq \\\"app\\\") {\\necho \\\"App server detected\\\" | tee -Append \\\"$LOG_FILE\\\"\\necho \\\"$C1ENV is our environment prefix. Determining ALB names\\\" | tee -Append \\\"$LOG_FILE\\\"\\n#similiar to above but for app server API's\\n$API_TGRP = $C1ENV+'-api'\\n$APIWS_TGRP = $C1ENV+'-apiws'\\n#echo \\\"API Target Group is $API_TGRP\\\" \\n#echo \\\"APIWS Target Group is $APIWS_TGRP\\\" \\n\\n$APITMP = & { aws elbv2 describe-target-groups --name $API_TGRP --region $AWS_REGION --output text } \\n$APIWSTMP = & { aws elbv2 describe-target-groups --name $APIWS_TGRP --region $AWS_REGION --output text } \\n\\n$APITMP_PARTS = $APITMP.split(\\\"\\t\\\") # Results delimited by tabs\\n$APIWSTMP_PARTS = $APIWSTMP.split(\\\"\\t\\\") # Results delimited by tabs\\n#echo $APITMP_PARTS\\n#echo $APIWSTMP_PARTS\\n$API_ARN = $APITMP_PARTS[9]\\n$APIWS_ARN = $APIWSTMP_PARTS[9]\\necho \\\"waiting $TGRP_CHANGE_WAIT seconds for APP server to to drain\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\naws elbv2 deregister-targets --target-group-arn $API_ARN --targets Id=$instanceid --region $AWS_REGION --output text\\naws elbv2 deregister-targets --target-group-arn $APIWS_ARN --targets Id=$instanceid --region $AWS_REGION --output text\\necho \\\"drain command sent, starting 300 second wait\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 240 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 180 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 120 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\necho \\\"waiting 60 seconds for the server to drain fully\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStart-Sleep -Seconds 60\\n\\n}\\n\\necho \\\"Starting upgrade\\\" | tee -Append \\\"$LOG_FILE\\\"\\n#echo \\\"Waiting 10 seconds.\\\"\\n#start-sleep -Seconds 10\\nGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\necho \\\"Stopping Services, some will fails as they are already disabled\\\" | tee -Append \\\"$LOG_FILE\\\"\\nStop-Service -Name 'ciWFO*' 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n#Stop-Service -Name 'ciWFO*'\\nif ($RoleTag.Value -eq \\\"app\\\") {\\n\\techo \\\"Killing any phantomjs processes...\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\ttaskkill /im phantomjs.exe -f 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n}\\n\\nif ($RoleTag.Value -eq \\\"grid\\\") {\\necho \\\"GRID server detected\\\" | tee -Append \\\"$LOG_FILE\\\"\\n#echo \\\"$C1ENV is our environment prefix. Determining ALB names\\\"\\n#echo \\\"waiting for 120 seconds for grid processes to complete. \\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\n\\techo \\\"waiting 120 seconds for the subtasks to complete. \\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Sleep -Seconds 60\\n\\techo \\\"waiting 60 seconds for the subtasks to complete. \\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Sleep -Seconds 60\\n\\techo \\\"Killing any grid task processes that didn't complete in 120 seconds.\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\ttaskkill /im scrypt.exe -f 2>&1\\n\\ttaskkill /im SPWcli.exe -f 2>&1\\n\\tStart-Sleep -Seconds 2\\n\\techo \\\"Killing any ADDITIONAL grid task processes that didn't complete in 120 seconds, twice, with a 5 second wait.\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\ttaskkill /im scrypt.exe -f 2>&1\\n\\ttaskkill /im SPWcli.exe -f 2>&1\\n\\n}\\n\\necho \\\"outputting current WFO service status:\\\"\\nGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n#echo \\\"sleeping 5 seconds after stopping services\\\"\\n#start-sleep -Seconds 5\\n\\n###############\\necho \\\"Removing old files\\\" | tee -Append \\\"$LOG_FILE\\\"\\n## Add checks to see if we have files to repleace the directories if needed...\\nRemove-Item 'C:\\\\Program Files\\\\Common Files\\\\Calabrio ONE\\\\Server\\\\Install\\\\Packages\\\\*' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Apache\\\\htdocs\\\\*' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\bin' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\webapps\\\\help' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\webapps\\\\api' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Broker\\\\bin' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Broker\\\\lib' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Grid\\\\bin' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Grid\\\\lib' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\WFM\\\\bin' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\WFM\\\\Compile\\\\lib' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\WFM\\\\Forecast\\\\lib' -Recurse -Force -Verbose\\nRemove-Item 'C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\WFM\\\\Scheduler\\\\lib' -Recurse -Force -Verbose\\n\\necho \\\"Coping new files\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\nCopy-Item \\\"C:\\\\Temp\\\\Releases\\\\$($SCC_VERSION)\\\\Program Files\\\\Calabrio ONE\\\\Server\\\" -Destination 'C:\\\\Program Files\\\\Calabrio ONE\\\\' -Recurse -Force -Verbose | tee -Append \\\"$LOG_FILE\\\"\\nCopy-Item \\\"C:\\\\Temp\\\\Releases\\\\$($SCC_VERSION)\\\\Program Files\\\\Common Files\\\" -Destination 'C:\\\\Program Files\\\\' -Recurse -Force -Verbose | tee -Append \\\"$LOG_FILE\\\"\\n#Copy-Item \\\"\\\\\\\\$($FILE_SERVER)\\\\ConfigManagement\\\\11.0\\\\Program Files\\\" -Destination 'C:\\\\' -Recurse -Force -Verbose\\n# Adding FFMPEG binaries \\necho \\\"Adding FFMPEG Binaries to app server bin folder\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffmpeg.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\bin\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffplay.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\bin\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffprobe.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\bin\\\" \\n\\necho \\\"Adding FFMPEG Binaries to grid server bin folder\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffmpeg.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Grid\\\\bin\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffplay.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Grid\\\\bin\\\"\\naws s3 cp s3://$S3BUCKET/ConfigManagement/AppServer/bin/ffprobe.exe \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\Grid\\\\bin\\\" \\n\\nif ($RoleTag.Value -eq \\\"app\\\" -And $KafkaConsumer.Value -eq \\\"False\\\") {\\necho \\\"KafkaConsumer not detected. Applying standard configuration\\\"\\n# Load the Java\\\\Options template\\n$REG_CONTENT = Get-Content \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\conf\\\\java_options.txt\\\"\\necho \\\"Registry Content is $REG_CONTENT\\\"\\n$REG_CONTENT = $REG_CONTENT -replace \\\"SERVER_ADDRESS\\\", $HOST_ADDRESS\\n$REG_CONTENT = $REG_CONTENT -replace \\\"SERVER_HOSTNAME\\\", $computername\\n$JVM_MEMORY  = Get-Content \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\conf\\\\jvm_memory.txt\\\"\\necho \\\"Application Server detected. Settting Java Heap Memory Size\\\" | tee -Append \\\"$LOG_FILE\\\"\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"Options\\\" -Value $REG_CONTENT\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"JvmMs\\\" -Value $JVM_MEMORY\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"JvmMx\\\" -Value $JVM_MEMORY\\necho \\\"Application server registry updated with parameters\\\" | tee -Append \\\"$LOG_FILE\\\"\\nstart-sleep -Seconds 3\\n$ServiceName = \\\"ciWFOTomcat\\\" \\n#Put the Setconfig stuff for the registry here.\\n\\tSet-Service $ServiceName -StartupType Automatic\\n\\techo \\\"Set $ServiceName to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Service $ServiceName\\n\\techo \\\"waiting 90 seconds for app to start\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tstart-sleep -Seconds 90\\n\\techo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n\\t# First we create the request.\\n\\techo \\\"Calling prereq API, waiting\\\"\\n\\t$HTTP_Request = [System.Net.WebRequest]::Create('http://localhost:8888/api/system/prerequisites')\\n\\n\\t# We then get a response from the site.\\n\\t$HTTP_Response = $HTTP_Request.GetResponse()\\n\\n\\t# We then get the HTTP code as an integer.\\n\\t$HTTP_Status = [int]$HTTP_Response.StatusCode\\n\\n\\tIf ($HTTP_Status -eq 200) {\\n    $HTTP_Response.Close()\\n\\techo \\\"adding target to API and APIWS Target Groups\\\" | tee -Append \\\"$LOG_FILE\\\"\\n    aws elbv2 register-targets --target-group-arn $API_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\taws elbv2 register-targets --target-group-arn $APIWS_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\techo \\\"Target registration is complete, welcome to the jungle!\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\t\\t\\t\\t\\t\\t \\n\\t#Else { \\n\\t#\\t\\tWrite-Host \\\"The Site may be down, please check!\\\" \\n\\t#\\texit\\n\\t#\\t}\\n\\t}\\t\\n}\\n\\nif ($RoleTag.Value -eq \\\"app\\\" -And $KafkaConsumer.Value -eq \\\"True\\\") {\\necho \\\"KafkaConsumer detected. Applying additional configuration\\\"\\n# Load the Java\\\\Options template\\n$REG_CONTENT = Get-Content \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\conf\\\\java_options.txt\\\"\\necho \\\"Registry Content is $REG_CONTENT\\\"\\n$REG_CONTENT = $REG_CONTENT -replace \\\"SERVER_ADDRESS\\\", $HOST_ADDRESS\\n$REG_CONTENT = $REG_CONTENT -replace \\\"SERVER_HOSTNAME\\\", $computername\\necho \\\"Adding Additional reg_content; -Dcom.calabrio.kafka.configDir=C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\kafka \\\" | tee -Append \\\"$LOG_FILE\\\"\\n$REG_CONTENT += \\\"-Dcom.calabrio.kafka.configDir=C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\kafka\\\"\\necho \\\"Kafka Configuration Set for $computername\\\" | tee -Append \\\"$LOG_FILE\\\"\\n$JVM_MEMORY  = Get-Content \\\"C:\\\\Program Files\\\\Calabrio ONE\\\\Server\\\\AppServer\\\\conf\\\\jvm_memory.txt\\\"\\necho \\\"Application Server detected. Settting Java Heap Memory Size\\\" | tee -Append \\\"$LOG_FILE\\\"\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"Options\\\" -Value $REG_CONTENT\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"JvmMs\\\" -Value $JVM_MEMORY\\nSet-ItemProperty -Path \\\"hklm:SOFTWARE\\\\Wow6432Node\\\\Apache Software Foundation\\\\Procrun 2.0\\\\ciWFOTomcat\\\\Parameters\\\\Java\\\" -Name \\\"JvmMx\\\" -Value $JVM_MEMORY\\necho \\\"Application server registry updated with parameters\\\" | tee -Append \\\"$LOG_FILE\\\"\\nstart-sleep -Seconds 3\\n  $ServiceName = \\\"ciWFOTomcat\\\" \\n  #Put the Setconfig stuff for the registry here.\\n  Set-Service $ServiceName -StartupType Automatic\\n  echo \\\"Set $ServiceName to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n  Start-Service $ServiceName\\n  echo \\\"waiting 90 seconds for app to start\\\" | tee -Append \\\"$LOG_FILE\\\"\\n  start-sleep -Seconds 90\\n  echo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n  Get-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n  # First we create the request.\\n  echo \\\"Calling prereq API, waiting\\\"\\n  $HTTP_Request = [System.Net.WebRequest]::Create('http://localhost:8888/api/system/prerequisites')\\n\\n\\t# We then get a response from the site.\\n\\t$HTTP_Response = $HTTP_Request.GetResponse()\\n\\n\\t# We then get the HTTP code as an integer.\\n\\t$HTTP_Status = [int]$HTTP_Response.StatusCode\\n\\n\\tIf ($HTTP_Status -eq 200) {\\n    $HTTP_Response.Close()\\n\\techo \\\"adding target to API and APIWS Target Groups\\\" | tee -Append \\\"$LOG_FILE\\\"\\n    aws elbv2 register-targets --target-group-arn $API_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\taws elbv2 register-targets --target-group-arn $APIWS_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\techo \\\"Target registration is complete, welcome to the jungle!\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\t}\\t\\n}\\nif ($RoleTag.Value -eq \\\"web\\\") {\\n\\t$ServiceName = \\\"ciWFOApache\\\" \\n\\tSet-Service $ServiceName -StartupType Automatic\\n\\techo \\\"Set $ServiceName to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Service $ServiceName\\n    start-sleep -Seconds 15\\n\\techo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n\\n\\techo \\\"Calling healthcheck.txt, waiting\\\" tee -Append \\\"$LOG_FILE\\\"\\n\\t$HTTP_Request = [System.Net.WebRequest]::Create('http://localhost/resources/healthcheck.txt')\\n\\t$HTTP_Response = $HTTP_Request.GetResponse()\\n\\t$HTTP_Status = [int]$HTTP_Response.StatusCode\\n\\tIf ($HTTP_Status -eq 200) \\n\\t\\t{\\techo \\\"200 Status for Web returned, adding to HTTP and HTTPS target groups\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\t\\t\\taws elbv2 register-targets --target-group-arn $HTTP_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\t\\t\\taws elbv2 register-targets --target-group-arn $HTTPS_ARN --targets Id=$instanceid --region $AWS_REGION --output text | tee -Append \\\"$LOG_FILE\\\"\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\nif ($RoleTag.Value -eq \\\"bro\\\") {\\n\\t$ServiceName = \\\"ciWFOBroker\\\" \\n\\tSet-Service $ServiceName -StartupType Automatic\\n\\techo \\\"Set $ServiceName to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Service $ServiceName\\t\\n\\techo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n\\techo \\\"waiting 300 seconds for broker to stabilize in case we move onto another broker very quickly\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Sleep -Seconds 300\\n}\\n\\t\\nif ($RoleTag.Value -eq \\\"grid\\\") {\\n\\t$ServiceName = \\\"ciWFOGrid\\\" \\n\\tSet-Service $ServiceName -StartupType Automatic\\n\\techo \\\"Set $ServiceName to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Service $ServiceName\\t\\n\\techo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n}\\n\\t\\nif ($RoleTag.Value -eq \\\"wfm\\\") {\\n\\t$ServiceName = \\\"ciWFOScheduler\\\" \\n\\t$ServiceName1 = \\\"ciWFOForecast\\\" \\n\\t$ServiceName2 = \\\"ciWFOCompile\\\"\\n\\tSet-Service $ServiceName -StartupType Automatic\\n\\tSet-Service $ServiceName1 -StartupType Automatic\\n\\tSet-Service $ServiceName2 -StartupType Automatic\\n\\techo \\\"Set $ServiceName, $ServiceName1, $ServiceName2 to automatic\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tStart-Service $ServiceName\\t\\n\\tStart-Service $ServiceName1\\n\\tStart-Service $ServiceName2\\n\\techo \\\"outputting current service status\\\" | tee -Append \\\"$LOG_FILE\\\"\\n\\tGet-Service -Name \\\"ciWFO*\\\" 2>&1  | tee -Append \\\"$LOG_FILE\\\"\\n}\\n\\necho \\\"Cleaning up\\\"\\nRemove-Item 'C:\\\\Temp\\\\Releases\\\\*' -Recurse -Force -Verbose  | tee -Append \\\"$LOG_FILE\\\"\\n\\necho \\\"Exiting.\\\" | tee  -Append \\\"$LOG_FILE\\\"\\nexit\" ]\n    }\n  } ]\n}",
  "CreatedDate": "2020-06-11T16:43:35.143Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Command"
  },
  "DocumentVersion": "16",
  "Name": "arn:aws:ssm:us-west-2:303795061870:document/patchC1-to-desiredversion",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "5e146db8-9436-465a-be3c-4464bade1c1a",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 25924,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-04-07T07:15:32.2382443+00:00"
}
