{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\" : \"# Id sns:test:break_delivery_to_sqs:2020-04-01\\n## Intent Test to break the delivery of messages to Amazon Amazon SNS subscriptions with an SQS queue as a target.\\n## Type Software Outage Test\\n## Risk High\\n## Requirements * An existing SNS topic with a subscription, which has the SQS protocol and a dead-letter queue enabled. * An alarm that tracks the number of failed notifications sent to a topic.\\n## Permissions required for AutomationAssumeRole * ssm:GetAutomationExecution * ssm:StartAutomationExecution * ssm:GetParameters * sqs:ReceiveMessage * sns:GetSubscriptionAttributes * sqs:GetQueueUrl * sqs:GetQueueAttributes * sqs:SetQueueAttributes * sqs:AddPermission * sqs:RemovePermission * iam:PassRole * cloudwatch:DescribeAlarms * cloudwatch:PutMetricAlarm\\n## Supports Rollback Yes. Users can run the script with `IsRollback` and `PreviousExecutionId` to rollback changes from the previous run.\\n## Inputs ### `SubscriptionArn`:\\n    type: String\\n    description: (Required) An Amazon SNS subscription ARN.\\n### `NumberOfNotificationsFailedAlarmName`:\\n    type: String\\n    description: (Required) An Alarm, which should be red after a failure injection and green after the rollback process at the end of the test.\\n### `IsRollback`:\\n    type: String\\n    description: (Optional) Run rollback step of the given previous execution parameter (`PreviousExecutionId`). Can be set to either true or false.\\n    default: \\\"false\\\"\\n### `PreviousExecutionId`:\\n    type: String\\n    description: (Optional) Previous execution ID for which resources need to be cleaned up.\\n    default: \\\"\\\"\\n### `AutomationAssumeRole`:\\n    type: String\\n    description: (Required) The ARN of the role that allows automation to perform the actions on your behalf.\\n\\n## Details The document updates the policy of an SNS subscription's target SQS queue, and tests if an alarm is triggered for the `NumberOfNotificationsFailed` metric. If there are no messages published to the SNS topic, the alarm will not be triggered and the document will time out. However, you must still rollback the injected failure.\\n## Steps executed in normal flow * CheckIsRollback * AssertAlarmToBeGreenBeforeTest * BackupCurrentExecution * GenerateBadQueuePolicy * InjectFailure * AssertAlarmToBeRed * RollbackCurrentExecution * AssertAlarmToBeGreen\\n## Steps executed in rollback flow * CheckIsRollback * GetInputsFromPreviousExecution * AssertSubscriptionArn * PrepareRollbackOfPreviousExecution * RollbackPreviousExecution\",\n  \"schemaVersion\" : \"0.3\",\n  \"assumeRole\" : \"{{ AutomationAssumeRole }}\",\n  \"parameters\" : {\n    \"SubscriptionArn\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) An Amazon SNS subscription ARN.\"\n    },\n    \"AutomationAssumeRole\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) The ARN of the role that allows automation to perform the actions on your behalf.\"\n    },\n    \"NumberOfNotificationsFailedAlarmName\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Required) An Alarm, which should be red after a failure injection and green after the rollback process in the end of the test.\"\n    },\n    \"IsRollback\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Run rollback step of the given previous execution parameter (`PreviousExecutionId`). Can be set to either true or false.\",\n      \"default\" : \"false\"\n    },\n    \"PreviousExecutionId\" : {\n      \"type\" : \"String\",\n      \"description\" : \"(Optional) Previous execution ID for which resources need to be cleaned up.\",\n      \"default\" : \"\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"CheckIsRollback\",\n    \"action\" : \"aws:branch\",\n    \"inputs\" : {\n      \"Choices\" : [ {\n        \"NextStep\" : \"GetInputsFromPreviousExecution\",\n        \"Variable\" : \"{{IsRollback}}\",\n        \"StringEquals\" : \"true\"\n      } ],\n      \"Default\" : \"AssertAlarmToBeGreenBeforeTest\"\n    }\n  }, {\n    \"name\" : \"GetInputsFromPreviousExecution\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"SubscriptionArn\",\n      \"Selector\" : \"$.Payload.SubscriptionArn[0]\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"get_inputs_from_ssm_execution\",\n      \"InputPayload\" : {\n        \"ExecutionId\" : \"{{ PreviousExecutionId }}\"\n      },\n      \"Script\" : \"import json\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\n\\n\\n\\ndef get_inputs_from_ssm_execution(events, context):\\n    output = {}\\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n    ssm = boto3.client('ssm', config=config)\\n\\n    if 'ExecutionId' not in events:\\n        raise KeyError('Requires ExecutionId')\\n\\n    if not events['ExecutionId']:\\n        raise KeyError('Requires not empty ExecutionId')\\n\\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\\n    response_parameters = response['AutomationExecution']['Parameters']\\n    # TODO DIG-853\\n    for parameter in response_parameters:\\n        output[parameter] = response_parameters[parameter]\\n\\n    return output\"\n    }\n  }, {\n    \"name\" : \"AssertSubscriptionArn\",\n    \"action\" : \"aws:branch\",\n    \"inputs\" : {\n      \"Choices\" : [ {\n        \"NextStep\" : \"PrepareRollbackOfPreviousExecution\",\n        \"Variable\" : \"{{ GetInputsFromPreviousExecution.SubscriptionArn }}\",\n        \"StringEquals\" : \"{{ SubscriptionArn }}\"\n      } ]\n    },\n    \"isEnd\" : true\n  }, {\n    \"name\" : \"PrepareRollbackOfPreviousExecution\",\n    \"description\" : \"Get the original SqsEndpointQueueUrl and SqsEndpointPolicy\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"SqsEndpointQueueUrl\",\n      \"Selector\" : \"$.Payload.SqsEndpointQueueUrl[0]\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"SqsEndpointPolicy\",\n      \"Selector\" : \"$.Payload.SqsEndpointPolicy[0]\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"get_output_from_ssm_step_execution\",\n      \"InputPayload\" : {\n        \"ExecutionId\" : \"{{ PreviousExecutionId }}\",\n        \"StepName\" : \"BackupCurrentExecution\",\n        \"ResponseField\" : \"SqsEndpointQueueUrl,SqsEndpointPolicy\"\n      },\n      \"Script\" : \"import json\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\n\\n\\ndef get_output_from_ssm_step_execution(events, context):\\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n    ssm = boto3.client('ssm', config=config)\\n\\n    if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:\\n        raise KeyError('Requires ExecutionId, StepName and ResponseField in events')\\n\\n    ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\\n    for step in ssm_response['AutomationExecution']['StepExecutions']:\\n        if step['StepName'] == events['StepName']:\\n            response_fields = events['ResponseField'].split(',')\\n            output = {}\\n            for response_field in response_fields:\\n                if response_field in step['Outputs']:\\n                    # Sets values in string type regardless of what is the original value type. In order to set\\n                    # values with original types please use 'get_typed_output_from_ssm_step_execution'.\\n                    output[response_field] = step['Outputs'][response_field]\\n                else:\\n                    \\\"\\\"\\\"\\n                    By default SSM ignores empty values when encodes API outputs to JSON. It may result in\\n                    a situation when an empty value is a valid value but step output completely misses it.\\n                    Usually happens with SQS queue policies, default policy is returned by API as an empty value\\n                    and executeApi step output ignores it. As a result, further steps in rollback execution will fail.\\n                    Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string\\n                    represents a default sqs policy\\n                    \\\"\\\"\\\"\\n                    output[response_field] = ['']\\n            return output\\n\\n    # Could not find step name\\n    raise Exception('Can not find step name % in ssm execution response', events['StepName'])\"\n    }\n  }, {\n    \"name\" : \"RollbackPreviousExecution\",\n    \"description\" : \"Apply original policy to the subscription target SQS queue from the previous execution.\",\n    \"maxAttempts\" : 5,\n    \"action\" : \"aws:executeAwsApi\",\n    \"inputs\" : {\n      \"Service\" : \"sqs\",\n      \"Api\" : \"SetQueueAttributes\",\n      \"QueueUrl\" : \"{{ PrepareRollbackOfPreviousExecution.SqsEndpointQueueUrl }}\",\n      \"Attributes\" : {\n        \"Policy\" : \"{{ PrepareRollbackOfPreviousExecution.SqsEndpointPolicy }}\"\n      }\n    },\n    \"isEnd\" : true\n  }, {\n    \"name\" : \"AssertAlarmToBeGreenBeforeTest\",\n    \"action\" : \"aws:waitForAwsResourceProperty\",\n    \"maxAttempts\" : 1,\n    \"timeoutSeconds\" : 300,\n    \"inputs\" : {\n      \"Service\" : \"cloudwatch\",\n      \"Api\" : \"DescribeAlarms\",\n      \"AlarmNames\" : [ \"{{NumberOfNotificationsFailedAlarmName}}\" ],\n      \"PropertySelector\" : \"$.MetricAlarms[0].StateValue\",\n      \"DesiredValues\" : [ \"OK\" ]\n    }\n  }, {\n    \"name\" : \"BackupCurrentExecution\",\n    \"description\" : \"Backup current execution.\",\n    \"action\" : \"aws:executeScript\",\n    \"outputs\" : [ {\n      \"Name\" : \"TopicArn\",\n      \"Selector\" : \"$.Payload.TopicArn\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"SqsEndpointQueueUrl\",\n      \"Selector\" : \"$.Payload.SqsEndpointQueueUrl\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"SqsEndpointQueueArn\",\n      \"Selector\" : \"$.Payload.SqsEndpointQueueArn\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"SqsEndpointPolicy\",\n      \"Selector\" : \"$.Payload.SqsEndpointPolicy\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"break_delivery_to_sqs_backup_current_execution\",\n      \"InputPayload\" : {\n        \"SubscriptionArn\" : \"{{ SubscriptionArn }}\"\n      },\n      \"Script\" : \"\\\"\\\"\\\"SNS util.\\\"\\\"\\\"\\n\\nimport json\\nimport logging\\nimport random\\nimport time\\nfrom datetime import datetime\\nfrom typing import List, Optional\\nfrom uuid import uuid4\\n\\nimport boto3\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nINITIAL_COUNT_OF_SUBSCRIPTIONS = 1\\n\\n\\n\\ndef get_queue_url_from_arn(sqs_client, queue_arn: str) -> dict:\\n    queue_name = queue_arn.split(':')[-1]\\n    queue_account_id = queue_arn.split(':')[-2]\\n\\n    if (not queue_name or not queue_account_id):\\n        raise ValueError(\\n            f'{\\\"Subscription target sqs queue is invalid\\\"}')\\n\\n    get_queue_url_response = sqs_client.get_queue_url(\\n        QueueName=queue_name,\\n        QueueOwnerAWSAccountId=queue_account_id\\n    )\\n\\n    return get_queue_url_response['QueueUrl']\\n\\n\\n\\ndef get_queue_policy(sqs_client, queue_url: str) -> dict:\\n    get_queue_attributes_response = sqs_client.get_queue_attributes(\\n        QueueUrl=queue_url,\\n        AttributeNames=['All'],\\n    )\\n\\n    sqs_endpoint_policy = get_queue_attributes_response['Attributes']['Policy']\\n\\n    return sqs_endpoint_policy\\n\\n\\n\\ndef backup_sns_sub_with_sqs_target(sub_arn: str, should_backup_dlq: bool) -> dict:\\n    config = Config(\\n        signature_version='v4',\\n        retries={\\n            'max_attempts': 10,\\n            'mode': 'standard'\\n        }\\n    )\\n    sns_client = boto3.client('sns', config=config)\\n    sqs_client = boto3.client(\\\"sqs\\\", config=config)\\n\\n    sub_attributes = sns_client.get_subscription_attributes(SubscriptionArn=sub_arn)['Attributes']\\n\\n    if (not sub_attributes.get('RedrivePolicy')):\\n        raise ValueError(\\n            f'{\\\"Redrive policy (dlq) must be present on the subscription\\\"}')\\n\\n    sub_sqs_endpoint_arn = sub_attributes['Endpoint']\\n\\n    sub_endpoint_queue_url = get_queue_url_from_arn(sqs_client, sub_sqs_endpoint_arn)\\n    sub_endpoint_queue_policy = get_queue_policy(sqs_client, sub_endpoint_queue_url)\\n\\n    if not should_backup_dlq:\\n        return {'TopicArn': sub_attributes['TopicArn'],\\n                'SqsEndpointQueueUrl': sub_endpoint_queue_url,\\n                'SqsEndpointQueueArn': sub_sqs_endpoint_arn,\\n                'SqsEndpointPolicy': sub_endpoint_queue_policy}\\n\\n    redrive_policy_parsed = json.loads(sub_attributes['RedrivePolicy'])\\n    dlq_arn = redrive_policy_parsed['deadLetterTargetArn']\\n\\n    dlq_url = get_queue_url_from_arn(sqs_client, dlq_arn)\\n    sub_dlq_policy = get_queue_policy(sqs_client, dlq_url)\\n\\n    return {'TopicArn': sub_attributes['TopicArn'],\\n            'SqsEndpointQueueUrl': sub_endpoint_queue_url,\\n            'SqsEndpointQueueArn': sub_sqs_endpoint_arn,\\n            'SqsDlqUrl': dlq_url,\\n            'SqsDlqArn': dlq_arn,\\n            'SqsEndpointPolicy': sub_endpoint_queue_policy,\\n            'SqsDlqPolicy': sub_dlq_policy}\\n\\n\\n\\ndef break_delivery_to_sqs_backup_current_execution(events: dict, context: dict) -> dict:\\n    sub_arn: str = events['SubscriptionArn']\\n    backup = backup_sns_sub_with_sqs_target(sub_arn, should_backup_dlq=False)\\n\\n    return backup\"\n    }\n  }, {\n    \"name\" : \"GenerateBadQueuePolicy\",\n    \"description\" : \"Generate queue policy that denies to send a message.\",\n    \"onFailure\" : \"step:RollbackCurrentExecution\",\n    \"onCancel\" : \"step:TriggerRollback\",\n    \"action\" : \"aws:executeScript\",\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"add_deny_in_sqs_policy\",\n      \"InputPayload\" : {\n        \"SourcePolicy\" : \"{{ BackupCurrentExecution.SqsEndpointPolicy }}\",\n        \"ActionsToDeny\" : [ \"sqs:SendMessage\" ],\n        \"Resource\" : \"{{ BackupCurrentExecution.SqsEndpointQueueArn }}\"\n      },\n      \"Script\" : \"import json\\nimport logging\\nimport random\\nimport time\\nimport uuid\\nfrom datetime import datetime\\nfrom typing import Callable, List, Optional\\n\\nimport boto3\\nfrom botocore.config import Config\\nfrom botocore.exceptions import ClientError\\n\\nlogger = logging.getLogger()\\nlogger.setLevel(logging.INFO)\\n\\n\\n\\ndef add_deny_in_sqs_policy(events: dict, context: dict) -> dict:\\n    \\\"\\\"\\\"\\n    Add deny policy statement(-s) to the SQS policy whether it is empty or not\\n    :return: updated SQS policy with deny\\n    \\\"\\\"\\\"\\n    if \\\"ActionsToDeny\\\" not in events or \\\"Resource\\\" not in events or \\\"SourcePolicy\\\" not in events:\\n        raise KeyError(\\\"Requires ActionsToDeny and Resource and SourcePolicy in events\\\")\\n\\n    actions_to_deny: List = events.get(\\\"ActionsToDeny\\\")\\n    resource: str = events.get(\\\"Resource\\\")\\n    source_policy: str = events.get(\\\"SourcePolicy\\\")\\n    source_policy = None if source_policy.startswith(\\\"{{\\\") else source_policy\\n\\n    deny_policy_statement_id: str = f\\\"DenyPolicyStatement-{uuid.uuid4()}\\\"\\n    deny_policy_statement: dict = {\\n        \\\"Effect\\\": \\\"Deny\\\",\\n        \\\"Sid\\\": deny_policy_statement_id,\\n        \\\"Principal\\\": \\\"*\\\",\\n        \\\"Action\\\": actions_to_deny,\\n        \\\"Resource\\\": resource,\\n    }\\n\\n    if source_policy is None:\\n        policy_id: str = f\\\"DenyPolicy-{uuid.uuid4()}\\\"\\n        sqs_policy: dict = {\\n            \\\"Version\\\": \\\"2012-10-17\\\",\\n            \\\"Id\\\": policy_id,\\n            \\\"Statement\\\": [deny_policy_statement]\\n        }\\n        return {\\\"Policy\\\": json.dumps(sqs_policy),\\n                \\\"PolicySid\\\": policy_id,\\n                \\\"DenyPolicyStatementSid\\\": deny_policy_statement_id}\\n    else:\\n        source_policy: dict = json.loads(source_policy)\\n        statement: List = source_policy.get(\\\"Statement\\\")\\n        if statement is None or len(statement) == 0:\\n            raise KeyError(\\\"Requires not empty Statement in SQS Policy\\\")\\n        statement.append(deny_policy_statement)\\n        return {\\\"Policy\\\": json.dumps(source_policy),\\n                \\\"PolicySid\\\": source_policy.get(\\\"Id\\\"),\\n                \\\"DenyPolicyStatementSid\\\": deny_policy_statement_id}\"\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"Policy\",\n      \"Selector\" : \"$.Payload.Policy\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"PolicySid\",\n      \"Selector\" : \"$.Payload.PolicySid\",\n      \"Type\" : \"String\"\n    }, {\n      \"Name\" : \"DenyPolicyStatementSid\",\n      \"Selector\" : \"$.Payload.DenyPolicyStatementSid\",\n      \"Type\" : \"String\"\n    } ]\n  }, {\n    \"name\" : \"InjectFailure\",\n    \"description\" : \"Inject failure by setting the queue policy to the generated one, which has deny-send-message permissions.\",\n    \"action\" : \"aws:executeAwsApi\",\n    \"onFailure\" : \"step:RollbackCurrentExecution\",\n    \"onCancel\" : \"step:TriggerRollback\",\n    \"inputs\" : {\n      \"Service\" : \"sqs\",\n      \"Api\" : \"SetQueueAttributes\",\n      \"QueueUrl\" : \"{{ BackupCurrentExecution.SqsEndpointQueueUrl }}\",\n      \"Attributes\" : {\n        \"Policy\" : \"{{ GenerateBadQueuePolicy.Policy }}\"\n      }\n    }\n  }, {\n    \"name\" : \"AssertAlarmToBeRed\",\n    \"action\" : \"aws:waitForAwsResourceProperty\",\n    \"maxAttempts\" : 1,\n    \"timeoutSeconds\" : 600,\n    \"onFailure\" : \"step:RollbackCurrentExecution\",\n    \"onCancel\" : \"step:TriggerRollback\",\n    \"inputs\" : {\n      \"Service\" : \"cloudwatch\",\n      \"Api\" : \"DescribeAlarms\",\n      \"AlarmNames\" : [ \"{{NumberOfNotificationsFailedAlarmName}}\" ],\n      \"PropertySelector\" : \"$.MetricAlarms[0].StateValue\",\n      \"DesiredValues\" : [ \"ALARM\" ]\n    }\n  }, {\n    \"name\" : \"RollbackCurrentExecution\",\n    \"description\" : \"Apply original policy to the subscription target SQS queue.\",\n    \"maxAttempts\" : 5,\n    \"onCancel\" : \"step:TriggerRollback\",\n    \"action\" : \"aws:executeAwsApi\",\n    \"inputs\" : {\n      \"Service\" : \"sqs\",\n      \"Api\" : \"SetQueueAttributes\",\n      \"QueueUrl\" : \"{{ BackupCurrentExecution.SqsEndpointQueueUrl }}\",\n      \"Attributes\" : {\n        \"Policy\" : \"{{ BackupCurrentExecution.SqsEndpointPolicy }}\"\n      }\n    }\n  }, {\n    \"name\" : \"AssertAlarmToBeGreen\",\n    \"action\" : \"aws:waitForAwsResourceProperty\",\n    \"maxAttempts\" : 1,\n    \"timeoutSeconds\" : 900,\n    \"inputs\" : {\n      \"Service\" : \"cloudwatch\",\n      \"Api\" : \"DescribeAlarms\",\n      \"AlarmNames\" : [ \"{{NumberOfNotificationsFailedAlarmName}}\" ],\n      \"PropertySelector\" : \"$.MetricAlarms[0].StateValue\",\n      \"DesiredValues\" : [ \"OK\" ]\n    },\n    \"isEnd\" : true\n  }, {\n    \"name\" : \"TriggerRollback\",\n    \"action\" : \"aws:executeScript\",\n    \"onFailure\" : \"Abort\",\n    \"outputs\" : [ {\n      \"Name\" : \"RollbackExecutionId\",\n      \"Selector\" : \"$.Payload.RollbackExecutionId\",\n      \"Type\" : \"String\"\n    } ],\n    \"inputs\" : {\n      \"Runtime\" : \"python3.8\",\n      \"Handler\" : \"start_rollback_execution\",\n      \"InputPayload\" : {\n        \"ExecutionId\" : \"{{automation:EXECUTION_ID}}\"\n      },\n      \"Script\" : \"import json\\n\\nimport boto3\\nfrom botocore.config import Config\\n\\n\\n\\n\\ndef start_rollback_execution(events, context):\\n    output = {}\\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\\n    ssm = boto3.client('ssm', config=config)\\n\\n    if 'ExecutionId' not in events or not events['ExecutionId']:\\n        raise KeyError('Requires not empty ExecutionId')\\n\\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\\n\\n    # Get parameters for current execution and add IsRollback and PreviousExecutionId\\n    response_parameters = response['AutomationExecution']['Parameters']\\n    response_parameters['IsRollback'] = ['true']\\n    response_parameters['PreviousExecutionId'] = [events['ExecutionId']]\\n\\n    rollback_execution_response = ssm.start_automation_execution(\\n        DocumentName=response['AutomationExecution']['DocumentName'],\\n        DocumentVersion=response['AutomationExecution']['DocumentVersion'],\\n        Parameters=response_parameters\\n    )\\n    output['RollbackExecutionId'] = rollback_execution_response['AutomationExecutionId']\\n    return output\"\n    },\n    \"isEnd\" : true\n  } ]\n}",
  "CreatedDate": "2023-02-19T17:14:21.693Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "4",
  "Name": "AWSResilienceHub-BreakSNSSubscriptionDeliveryToSQSTest_2020-04-01",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "e62eeab0-8ebe-4b14-bfbf-d4da0c533ed4",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 21342,
  "HttpStatusCode": 200,
  "LoggedAt": "2023-05-16T07:12:15.1775957+00:00"
}
