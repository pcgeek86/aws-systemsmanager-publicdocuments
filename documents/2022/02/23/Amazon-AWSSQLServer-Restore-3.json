{
  "AttachmentsContent": [],
  "Content": "{\n  \"description\" : \"#### Downloads SQL Server backups from Amazon S3 to local storage, and optionally restores the database from a backup.\\n---\\n#### Prerequisites for using this document:\\n* Instance(s) must be running SQL Server.\\n* An AWS Secrets Manager database credential must be configured with with the following two fields: **username** and **password**. For instructions, see the [documentation](http://docs.aws.amazon.com/launchwizard/latest/userguide/launch-wizard-sql-provided-runbooks.html).\\n* On Windows, the **username** and **password** must be the domain account and password used to authenticate SQL Server. The domain user must be a local administrator.\\n* On Linux, the **username** and **password** must be the SQL Server login  name and password.\\n* The Amazon S3 database backup must have been performed by the following AWS backup document: [PlaceHolderForLink].\\n* The Amazon S3 database backups must include at least one FULL database backup.\\n* The **username** must be assigned, at minimum, the following database role: **db_owner**.\\n* Instances may need to be granted additional permissions and roles that allow access to AWS Secrets Manager credentials and Amazon S3. For more information, see [PlaceHolderForLink].\\n---\\nThis document can optionally restore a database from a backup using the latest FULL backup for the specified time range. It then applies the latest DIFF and LOG backups performed after the latest complete backup.\",\n  \"schemaVersion\" : \"0.3\",\n  \"parameters\" : {\n    \"InstanceId\" : {\n      \"type\" : \"StringList\",\n      \"description\" : \"Target SQL Server instance on which to perform backup operation\"\n    },\n    \"Database\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"^[a-zA-Z_][\\\\w@$#_]{0,127}$\",\n      \"description\" : \"Database to restore\"\n    },\n    \"S3Bucket\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"(?=^.{3,63}$)(?!^(\\\\\\\\d+\\\\\\\\.)+\\\\\\\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\\\\\\\-]*[a-z0-9])\\\\\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\\\\\-]*[a-z0-9])$)\",\n      \"description\" : \"Amazon S3 bucket that contains the backup files (for example, my-backup-bucket)\"\n    },\n    \"S3BucketFolder\" : {\n      \"type\" : \"String\",\n      \"allowedPattern\" : \"^[a-zA-Z0-9/!-_.*'()]*$\",\n      \"description\" : \"Amazon S3 folder that contains the backup files (for example, SqlBackups)\"\n    },\n    \"RestoreAction\" : {\n      \"type\" : \"String\",\n      \"allowedValues\" : [ \"Copy FULL, DIFF, and LOG files to local storage\", \"Copy FULL, DIFF, and LOG files to local storage, and restore database from backup\" ],\n      \"description\" : \"Specifies whether restore action should only download files, or download and restore database\",\n      \"default\" : \"\"\n    },\n    \"DownloadDirectory\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Local directory path for download from Amazon S3. For example, C:\\\\Download (Windows), /home/user/download (Linux)\",\n      \"allowedPattern\" : \"^[a-zA-Z]\\\\:\\\\\\\\[\\\\w_\\\\-\\\\.\\\\\\\\!@#$%^+-=~{};,]{1,180}$|^\\\\/[\\\\w_\\\\-\\\\.\\\\/!@#$%^+-=~{};,]{1,180}$\"\n    },\n    \"DataFilesDirectory\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Optional local directory path for remapping logical database files, such as .ldf and .mdf files\",\n      \"allowedPattern\" : \"^[a-zA-Z]\\\\:\\\\\\\\[\\\\w_\\\\-\\\\.\\\\\\\\!@#$%^+-=~{};,]{1,180}$|^\\\\/[\\\\w_\\\\-\\\\.\\\\/!@#$%^+-=~{};,]{1,180}$|^$\",\n      \"default\" : \"\"\n    },\n    \"DateRangeNotBefore\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Optionally specified file date after which files will not be considered for restore. Must use YYYY/MM/DD format.\",\n      \"allowedPattern\" : \"(^([12]\\\\d{3}\\\\/(0[1-9]|1[0-2])\\\\/(0[1-9]|[12]\\\\d|3[01]))$)|^$\",\n      \"default\" : \"\"\n    },\n    \"DateRangeNotAfter\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Optionally specified file date before which files will not be considered for restore. Must use the YYYY/MM/DD format.\",\n      \"allowedPattern\" : \"(^([12]\\\\d{3}\\\\/(0[1-9]|1[0-2])\\\\/(0[1-9]|[12]\\\\d|3[01]))$)|^$\",\n      \"default\" : \"\"\n    },\n    \"SecretsMangerCredential\" : {\n      \"type\" : \"String\",\n      \"description\" : \"Optionally specified name of the AWS Secrets Manager database secret, which is required for database restore\",\n      \"allowedPattern\" : \"^[\\\\/_+=\\\\.@\\\\-a-zA-Z0-9]{1,512}$|^$\",\n      \"default\" : \"\"\n    }\n  },\n  \"mainSteps\" : [ {\n    \"name\" : \"GetInstanceOSInfo\",\n    \"action\" : \"aws:executeAwsApi\",\n    \"inputs\" : {\n      \"Service\" : \"ssm\",\n      \"Api\" : \"DescribeInstanceInformation\",\n      \"Filters\" : [ {\n        \"Key\" : \"InstanceIds\",\n        \"Values\" : [ \"{{ InstanceId }}\" ]\n      } ]\n    },\n    \"outputs\" : [ {\n      \"Name\" : \"platform\",\n      \"Selector\" : \"$.InstanceInformationList[0].PlatformType\",\n      \"Type\" : \"String\"\n    } ]\n  }, {\n    \"name\" : \"BranchOnWindowsOrLinux\",\n    \"action\" : \"aws:branch\",\n    \"inputs\" : {\n      \"Choices\" : [ {\n        \"NextStep\" : \"ExecuteRestore\",\n        \"Variable\" : \"{{GetInstanceOSInfo.platform}}\",\n        \"StringEquals\" : \"Windows\"\n      }, {\n        \"NextStep\" : \"InstallPowerShellOnLinux\",\n        \"Variable\" : \"{{GetInstanceOSInfo.platform}}\",\n        \"StringEquals\" : \"Linux\"\n      } ]\n    }\n  }, {\n    \"name\" : \"InstallPowerShellOnLinux\",\n    \"action\" : \"aws:runCommand\",\n    \"inputs\" : {\n      \"DocumentName\" : \"AWS-RunShellScript\",\n      \"InstanceIds\" : \"{{ InstanceId }}\",\n      \"Parameters\" : {\n        \"commands\" : \"if [ \\\"$(which pwsh > /dev/null 2>&1; echo $?)\\\" -ne \\\"0\\\" ]\\nthen\\n   sudo apt-get install -y powershell\\nfi\"\n      }\n    }\n  }, {\n    \"name\" : \"ExecuteRestore\",\n    \"action\" : \"aws:runCommand\",\n    \"inputs\" : {\n      \"DocumentName\" : \"AWS-RunPowerShellScript\",\n      \"InstanceIds\" : \"{{ InstanceId }}\",\n      \"Parameters\" : {\n        \"commands\" : [ \"function VerifySignature { param( [Parameter(Mandatory=$true)] $FilePath, [Parameter(Mandatory=$true)] $SignatureFilePath ) $code = \\\" using System; using System.IO; using System.Security.Cryptography; namespace Crypto { public class CryptoHelper { public static bool VerifySignature(string FilePath, string SignatureFilePath) { try { var modulus = Convert.FromBase64String(\\\"\\\"68hw9z3PIC7u5VkEoWeOI+f63hf3+FTDidjgEYkbsGVJ/8Yip0tIyk7rw84AEA9mlZ8c9k5U0dZo18fLGYhRkfgytLVwaXXU8083DwTGj5n8TvTrKss8ugschfGQJIanyWR7eRFLxuYZS5fo2lxur8K+6rc7yDgM+zQTzoOz2GDcTMm3MY3aST9/SShmJLoc6yoekXifyCebSFt8PZ0lmARFiHupepDrZlqXKY/490MlEiZz2fh7RjOORTDZo85Ai/prxxRuHnXrlIBDCbWfCqPCphJD9IMYcbFUxMfL1M7WXCheAtPpzJjMpdLQ+QIzOY1gdvTxx9ml4BtcdXyyE1BE0gFmR8QHBzJIE6KWE7OSEQpPnqwJ+zkA79Mr9/Ud4gdKeI2rGWN7quspSn7nCXcfbG+j9Rc0JMpKgaVLhfXxC0/xWS6JO4HCgrfh5rXWjAN+HVeHDI2iuPOALrHSUPK9hFudqDWSCEhBO3WcVTeg7dzU2M8rx92ypfbThEhczwXQ3yXGbojUzEPv8M24tOsjDZtPlyErE9xwtVY4UBUuJPsjbxLYx/Bq8Fg79liIVITRDH+UQFGws3YZe8EqSOpyk8hY6rOXXXU0uVLpjMny1tmxngdFRaTnQtNUoqV4NBT1wTTSNKEx/O04fEfU7Jha6oaeZ1NaL4F4wApmAh0=\\\"\\\"); var exponent = Convert.FromBase64String(\\\"\\\"AQAB\\\"\\\"); var rsa = RSA.Create(new RSAParameters {Exponent = exponent, Modulus = modulus}); using (var stream = File.OpenRead(FilePath)) { var signatureBytes = File.ReadAllBytes(SignatureFilePath); var bytesToVerify = SHA256.Create().ComputeHash(stream); return rsa.VerifyData(bytesToVerify, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); } } catch (Exception e) { Console.WriteLine(e.ToString()); return false; } } } } \\\"; Add-Type -TypeDefinition $code -Language CSharp -ErrorAction Stop; return [Crypto.CryptoHelper]::VerifySignature($FilePath, $SignatureFilePath); }\\nfunction ExecuteScript { param( [Parameter(Mandatory=$true)] $ScriptFileName, [Parameter(Mandatory=$true)] $ScriptExpression)\\n$ExitCode = 1; $Result = \\\"\\\"; $TempFolder = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.Guid]::NewGuid()); $null = New-Item -ItemType Directory -Path $TempFolder -ErrorAction Stop; try { $MaintenanceZip = \\\"aws-maintenance.zip\\\"; $MaintenanceZipSig = \\\"aws-maintenance.zip.sig\\\"; $Prefix = \\\"3fae63dc-d9c3-40b1-a8c5-e03461b2ee9a\\\"; $Stage  = \\\"prod\\\"; $Region = \\\"{{global:REGION}}\\\"; $S3Domain = \\\"s3.amazonaws.com\\\"; if ($Region.Contains(\\\"gov\\\")) { $S3Domain = \\\"s3-$Region.amazonaws.com\\\"; } $URI=\\\"https://launchwizardscript-$Stage-$Region.$S3Domain/$Prefix/Maintenance/\\\"; $ZipFile = Join-Path -Path $TempFolder -ChildPath $MaintenanceZip; $ZipFileSig = Join-Path -Path $TempFolder -ChildPath $MaintenanceZipSig; $ScriptPath = Join-Path -Path $TempFolder -ChildPath \\\"Maintenance\\\"; $ScriptPath = Join-Path -Path $ScriptPath -ChildPath $ScriptFileName; $ProgressPreference = \\\"SilentlyContinue\\\"; $global:ProgressPreference = \\\"SilentlyContinue\\\"; $null = Invoke-WebRequest -Uri ($URI+$MaintenanceZip) -OutFile $ZipFile -ErrorAction Stop; $null = Invoke-WebRequest -Uri ($URI+$MaintenanceZipSig) -OutFile $ZipFileSig -ErrorAction Stop; if ((VerifySignature $ZipFile $ZipFileSig) -ne $true) { throw \\\"Signature validation failed\\\" } $null = Expand-Archive -Path $ZipFile -DestinationPath $TempFolder -ErrorAction Stop; $ScriptBlock = [scriptblock]::Create(\\\". $ScriptPath; $ScriptExpression\\\"); $Result = Invoke-Command -ScriptBlock $ScriptBlock -ErrorAction Stop; } catch { Write-Output $_.Exception; } finally { $Null = Remove-Item $TempFolder -Recurse -Force -ErrorAction SilentlyContinue; if (($null -eq $Result) -or ($Result.GetType().FullName -eq \\\"System.String\\\")) { Write-Output \\\"Unknown execution failure $Result\\\"; exit(1) } else { $Len = $Result.Length-1; $ExitCode = $Result[$Len]; $Len2 = $Len-1; Write-Output $Result[0..$Len2]; exit($ExitCode) } } } try { Set-StrictMode -Version latest; $Map = @{\\\"Copy FULL, DIFF, and LOG files to local storage\\\" = \\\"Download\\\"; \\\"Copy FULL, DIFF, and LOG files to local storage, and restore database from backup\\\" = \\\"DownloadAndRestore\\\"}; $RestoreAction = $Map[\\\"{{RestoreAction}}\\\"];\\n$SecretsMangerCredential = \\\"{{SecretsMangerCredential}}\\\"; $RestoreExpression = \\\"\\\"; if ($RestoreAction -eq \\\"DownloadAndRestore\\\") { if (($SecretsMangerCredential -eq \\\"\\\") -or (\\\"{{DataFilesDirectory}}\\\" -eq \\\"\\\")) { Write-Output \\\"The AWS Secrets Manager credential and the data files directory must be specified when restoring the database\\\"; exit(1) } $RestoreExpression = \\\"-SecretsManagerId $SecretsMangerCredential  -DataFilesDirectory {{DataFilesDirectory}}\\\" };\\n$DateExpression = \\\"\\\"; if (\\\"{{DateRangeNotBefore}}\\\" -ne \\\"\\\") { $DateExpression = \\\" -DateRangeNotBefore {{DateRangeNotBefore}}000000\\\"; $DateExpression = $DateExpression.Replace(\\\"/\\\", \\\"\\\"); }\\nif (\\\"{{DateRangeNotAfter}}\\\" -ne \\\"\\\") { $DateExpression += \\\" -DateRangeNotAfter {{DateRangeNotAfter}}235959\\\"; $DateExpression = $DateExpression.Replace(\\\"/\\\", \\\"\\\"); }\\n$ScriptExpression = \\\"RestoreDatabase -S3BucketAndFolder {{S3Bucket}}/{{S3BucketFolder}} -DownloadDirectory {{DownloadDirectory}} \\\" + \\\"-Database {{Database}}  -RestoreAction $RestoreAction $RestoreExpression $DateExpression\\\"; ExecuteScript -ScriptFileName \\\"aws-sqlrestore.ps1\\\" -ScriptExpression $ScriptExpression; } catch { Write-Output $_.Exception; exit(1) }\" ],\n        \"executionTimeout\" : \"172800\"\n      }\n    },\n    \"timeoutSeconds\" : 172800\n  } ]\n}",
  "CreatedDate": "2022-02-09T21:07:27.914Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "3",
  "Name": "AWSSQLServer-Restore",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "a82ca205-3db3-43a8-b7bc-676d99feb1dd",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 11913,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-02-23T07:11:52.1310362+00:00"
}
