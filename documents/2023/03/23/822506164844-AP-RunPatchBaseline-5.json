{
  "AttachmentsContent": [],
  "Content": "{\n  \"schemaVersion\": \"2.2\",\n  \"description\": \"Nordcloud custom version of AWS-RunPatchBaseline\",\n  \"parameters\": {\n    \"Operation\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) The update or configuration to perform on the instance. The system checks if patches specified in the patch baseline are installed on the instance. The install operation installs patches missing from the baseline.\",\n      \"allowedValues\": [\n        \"Scan\",\n        \"Install\"\n      ]\n    },\n    \"Distro\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The distribution of targeted machine\",\n      \"default\": \"\"\n    },\n    \"PackagesUploadURL\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The presigned S3 put URL to upload json with packages urls\",\n      \"default\": \"\"\n    },\n    \"SnapshotId\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The snapshot ID to use to retrieve a patch baseline snapshot.\",\n      \"allowedPattern\": \"(^$)|^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\",\n      \"default\": \"\"\n    },\n    \"InstallOverrideList\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) An https URL or an Amazon S3 path-style URL to the list of patches to be installed. This patch installation list overrides the patches specified by the default patch baseline.\",\n      \"allowedPattern\": \"(^$)|^https://.+$|^s3://([^/]+)/(.*?([^/]+))$\",\n      \"default\": \"\"\n    },\n    \"RebootOption\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan.\",\n      \"allowedValues\": [\n        \"RebootIfNeeded\",\n        \"NoReboot\"\n      ],\n      \"default\": \"RebootIfNeeded\"\n    },\n    \"BaselineOverrideURL\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) An HTTPS URL with custom baseline\",\n      \"default\": \"\"\n    }\n  },\n  \"mainSteps\": [\n    {\n      \"precondition\": {\n        \"StringEquals\": [\n          \"platformType\",\n          \"Linux\"\n        ]\n      },\n      \"action\": \"aws:runShellScript\",\n      \"name\": \"PatchLinux\",\n      \"inputs\": {\n        \"timeoutSeconds\": 7200,\n        \"runCommand\": [\n          \"#!/bin/bash\",\n          \"PYTHON_CMD=''\",\n          \"\",\n          \"check_binary() {\",\n          \"    HAS_VAR_NAME=HAS_$2\",\n          \"    CMD_VAR_NAME=$2_CMD\",\n          \"    if [ \\\"$(eval echo \\\\${${HAS_VAR_NAME}})\\\" = \\\"0\\\" ]; then return; fi\",\n          \"    which $1 2>/dev/null\",\n          \"    RET_CODE=$?\",\n          \"    eval \\\"${HAS_VAR_NAME}=${RET_CODE}\\\"\",\n          \"    if [ ${RET_CODE} -eq 0 ]; then eval \\\"${CMD_VAR_NAME}=$1\\\"; fi\",\n          \"}\",\n          \"\",\n          \"check_binary python3 PYTHON3\",\n          \"check_binary python2.6 PYTHON2_6\",\n          \"check_binary python26 PYTHON26\",\n          \"check_binary python2.7 PYTHON2_7\",\n          \"check_binary python27 PYTHON27\",\n          \"check_binary python2 PYTHON2\",\n          \"\",\n          \"which python 2>/dev/null\",\n          \"if [ $? -eq 0 ]; then\",\n          \"  PYTHON_VERSION=$(python --version 2>&1 | grep -Po '(?<=Python )[\\\\d]')\",\n          \"  eval \\\"HAS_PYTHON${PYTHON_VERSION}=0\\\"\",\n          \"  eval \\\"PYTHON${PYTHON_VERSION}_CMD='python'\\\"\",\n          \"fi\",\n          \"\",\n          \"check_binary apt-get APT\",\n          \"check_binary yum YUM\",\n          \"check_binary zypper ZYPP\",\n          \"\",\n          \"check_install_code() {\",\n          \"    if [ $1 -ne 0 ]\",\n          \"    then\",\n          \"        echo \\\"WARNING: Could not install the $2, this may cause the patching operation to fail.\\\" >&2\",\n          \"    fi\",\n          \"}\",\n          \"\",\n          \"CANDIDATES=( $HAS_PYTHON2_6 $HAS_PYTHON26 $HAS_PYTHON2_7 $HAS_PYTHON27 $HAS_PYTHON2 )\",\n          \"for CANDIDATE in \\\"${CANDIDATES[@]}\\\"\",\n          \"do\",\n          \"    if [ $CANDIDATE -eq 0 ]\",\n          \"    then\",\n          \"        HAS_ANY_PYTHON2=0\",\n          \"    fi\",\n          \"done\",\n          \"HAS_ANY_PYTHON2=${HAS_ANY_PYTHON2:-1}\",\n          \"\",\n          \"if [ $HAS_APT -eq 0 -a $HAS_PYTHON3 -eq 0 ]\",\n          \"then\",\n          \"    PYTHON_CMD=${PYTHON3_CMD}\",\n          \"    apt-get install python3-apt -y\",\n          \"    check_install_code $? \\\"python3-apt\\\"\",\n          \"\",\n          \"elif [ $HAS_YUM -eq 0 -a $HAS_ANY_PYTHON2 -eq 0 ]\",\n          \"then\",\n          \"\",\n          \"    HAS_COMPATIBLE_YUM=false\",\n          \"\",\n          \"    INSTALLED_PYTHON=( $PYTHON2_7_CMD $PYTHON27_CMD $PYTHON2_CMD $PYTHON2_6_CMD $PYTHON26_CMD  )\",\n          \"    for TEST_PYTHON_CMD in \\\"${INSTALLED_PYTHON[@]}\\\"\",\n          \"    do\",\n          \"        ${TEST_PYTHON_CMD} -c \\\"import yum\\\" 2>/dev/null\",\n          \"        if [ $? -ne 0 ]; then\",\n          \"            echo \\\"Unable to import yum module on $TEST_PYTHON_CMD\\\"\",\n          \"        else\",\n          \"            PYTHON_CMD=${TEST_PYTHON_CMD}\",\n          \"            HAS_COMPATIBLE_YUM=true\",\n          \"            break\",\n          \"        fi\",\n          \"    done\",\n          \"    if ! $HAS_COMPATIBLE_YUM; then\",\n          \"        echo \\\"Unable to import yum module, please check version compatibility between Yum and Python\\\"\",\n          \"        exit 1\",\n          \"    else\",\n          \"        YUM_VERSION=$(yum --version 2>/dev/null | sed -n 1p)\",\n          \"        echo \\\"Using Yum version: $YUM_VERSION\\\"\",\n          \"    fi\",\n          \"\",\n          \"elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON2 -eq 0 ]\",\n          \"then\",\n          \"    PYTHON_CMD=${PYTHON2_CMD}\",\n          \"elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON3 -eq 0 ]\",\n          \"then\",\n          \"    PYTHON_CMD=${PYTHON3_CMD}\",\n          \"else\",\n          \"    echo \\\"An unsupported package manager and python version combination was found. Yum requires Python2 and Apt requires Python 3.\\\"\",\n          \"    echo \\\"Python3=$HAS_PYTHON3, Python2=$HAS_ANY_PYTHON2, Yum=$HAS_YUM, Apt=$HAS_APT, Zypper=$HAS_ZYPP\\\"\",\n          \"    echo \\\"Exiting...\\\"\",\n          \"    exit 1\",\n          \"fi\",\n          \"\",\n          \"set -e\",\n          \"echo \\\"Using python binary: '${PYTHON_CMD}'\\\"\",\n          \"PYTHON_VERSION=$(${PYTHON_CMD} --version  2>&1)\",\n          \"echo \\\"Using Python Version: $PYTHON_VERSION\\\"\",\n          \"\",\n          \"export BASELINE_OVERRIDE_URL=\\\"{{BaselineOverrideURL}}\\\"\",\n          \"\",\n          \"echo '\",\n          \"import errno\",\n          \"import hashlib\",\n          \"import json\",\n          \"import logging\",\n          \"import os\",\n          \"import shutil\",\n          \"import subprocess\",\n          \"import tarfile\",\n          \"import sys\",\n          \"\",\n          \"tmp_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations/\\\")\",\n          \"reboot_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-194/\\\")\",\n          \"reboot_with_failure_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-195/\\\")\",\n          \"reboot_with_dependency_failure_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-196/\\\")\",\n          \"\",\n          \"ERROR_CODE_MAP = {\",\n          \"    151: \\\"%s sha256 check failed, should be %s, but is %s\\\",\",\n          \"    152: \\\"Unable to load and extract the content of payload, abort.\\\",\",\n          \"    154: \\\"Unable to create dir: %s\\\",\",\n          \"    155: \\\"Unable to extract tar file: %s.\\\",\",\n          \"    156: \\\"Unable to download payload: %s.\\\"\",\n          \"}\",\n          \"\",\n          \"# When an install occurs and the instance needs a reboot, the agent restarts our plugin.\",\n          \"# Check if these folders exist to know how to succeed or fail a command after a reboot.\",\n          \"# DO NOT remove these files here. They are cleaned in the common startup.\",\n          \"if os.path.exists(reboot_dir) or os.path.exists(reboot_with_failure_dir) or os.path.exists(reboot_with_dependency_failure_dir):\",\n          \"    sys.exit(0)\",\n          \"\",\n          \"\",\n          \"def create_dir(dirpath):\",\n          \"    dirpath = os.path.abspath(dirpath)\",\n          \"    if not os.path.exists(dirpath):\",\n          \"        try:\",\n          \"            os.makedirs(dirpath)\",\n          \"        except OSError as e:  # Guard against race condition\",\n          \"            if e.errno != errno.EEXIST:\",\n          \"                raise e\",\n          \"        except Exception as e:\",\n          \"            logger.error(\\\"Unable to create dir: %s\\\", dirpath)\",\n          \"            logger.exception(e)\",\n          \"            abort(154, (dirpath))\",\n          \"\",\n          \"\",\n          \"def use_curl():\",\n          \"    output, has_curl = shell_command([\\\"which\\\", \\\"curl\\\"])\",\n          \"    if has_curl == 0:\",\n          \"        return True\",\n          \"    else:\",\n          \"        return False\",\n          \"\",\n          \"\",\n          \"def download_to(url, file_path):\",\n          \"    curl_present = use_curl()\",\n          \"    logger.info(\\\"Downloading payload from %s\\\", url)\",\n          \"    if curl_present:\",\n          \"        output, curl_return = shell_command([\\\"curl\\\", \\\"-f\\\", \\\"-o\\\", file_path, url])\",\n          \"    else:\",\n          \"        output, curl_return = shell_command([\\\"wget\\\", \\\"-O\\\", file_path, url])\",\n          \"\",\n          \"    if curl_return != 0:\",\n          \"        download_agent = \\\"curl\\\" if curl_present else \\\"wget\\\"\",\n          \"        logger.error(\\\"Error code returned from %s is %d\\\", download_agent, curl_return)\",\n          \"        abort(156, (url))\",\n          \"\",\n          \"\",\n          \"def download(url):\",\n          \"    if use_curl():\",\n          \"        url_contents, curl_return = shell_command([\\\"curl\\\", url])\",\n          \"    else:\",\n          \"        url_contents, curl_return = shell_command([\\\"wget\\\", \\\"-O-\\\", url])\",\n          \"    if curl_return == 0:\",\n          \"        return url_contents\",\n          \"    else:\",\n          \"        raise Exception(\\\"Could not curl %s\\\" % url)\",\n          \"\",\n          \"\",\n          \"def extract_tar(path):\",\n          \"    path = os.path.abspath(path)\",\n          \"    try:\",\n          \"        f = tarfile.open(path, \\\"r|gz\\\")\",\n          \"        f.extractall()\",\n          \"    except Exception as e:\",\n          \"        logger.error(\\\"Unable to extract tar file: %s.\\\", path)\",\n          \"        logger.exception(e)\",\n          \"        abort(155, (path))\",\n          \"    finally:\",\n          \"        f.close()\",\n          \"\",\n          \"\",\n          \"def shell_command(cmd_list):\",\n          \"    with open(os.devnull, \\\"w\\\") as devnull:\",\n          \"        p = subprocess.Popen(cmd_list, stdout=subprocess.PIPE, stderr=devnull)\",\n          \"        (std_out, _) = p.communicate()\",\n          \"        if not type(std_out) == str:\",\n          \"            std_out = std_out.decode(\\\"utf-8\\\")\",\n          \"        return (std_out, p.returncode)\",\n          \"\",\n          \"\",\n          \"def abort(error_code, params = ()):\",\n          \"    if os.path.exists(tmp_dir):\",\n          \"        shutil.rmtree(tmp_dir)\",\n          \"    sys.stderr.write(ERROR_CODE_MAP.get(error_code) % params)\",\n          \"    sys.exit(error_code)\",\n          \"\",\n          \"def sha256_checksum(filename):\",\n          \"    sha256_hash = hashlib.sha256()\",\n          \"    with open(filename,\\\"rb\\\") as f:\",\n          \"        # Read and update hash string value in blocks of 4K\",\n          \"        for byte_block in iter(lambda: f.read(4096),b\\\"\\\"):\",\n          \"            sha256_hash.update(byte_block)\",\n          \"        return sha256_hash.hexdigest().upper()\",\n          \"\",\n          \"\",\n          \"# cd into the temp directory\",\n          \"create_dir(tmp_dir)\",\n          \"os.chdir(tmp_dir)\",\n          \"\",\n          \"# initialize logging\",\n          \"LOGGER_FORMAT = \\\"%(asctime)s %(name)s [%(levelname)s]: %(message)s\\\"\",\n          \"LOGGER_DATEFORMAT = \\\"%m/%d/%Y %X\\\"\",\n          \"LOGGER_LEVEL = logging.INFO\",\n          \"LOGGER_STREAM = sys.stdout\",\n          \"\",\n          \"logging.basicConfig(format=LOGGER_FORMAT, datefmt=LOGGER_DATEFORMAT, level=LOGGER_LEVEL, stream=LOGGER_STREAM)\",\n          \"logger = logging.getLogger()\",\n          \"\",\n          \"# main logic\",\n          \"s3_bucket = \\\"autopatcher-baseline-linux-bucket-sternik\\\"\",\n          \"region = \\\"eu-west-1\\\"\",\n          \"payload_name = \\\"patch-baseline-linux.tar.gz\\\"\",\n          \"payload_sha256 = \\\"AA32AAB6A58503B1193AF07DC44AE96EF7B41D8B052614CEE3788C2CE955A73B\\\"\",\n          \"\",\n          \"url_template = \\\"https://%s.s3.%s.amazonaws.com/%s\\\"\",\n          \"\",\n          \"download_to(url_template % (s3_bucket, region, payload_name), payload_name)\",\n          \"\",\n          \"# payloads are the actual files to be used for linux patching\",\n          \"payloads = []\",\n          \"try:\",\n          \"    sha256_code = sha256_checksum(payload_name)\",\n          \"    if not sha256_code == payload_sha256:\",\n          \"        error_msg = \\\"%s sha256 check failed, should be %s, but is %s\\\" % (payload_name, payload_sha256, sha256_code)\",\n          \"        logger.error(error_msg)\",\n          \"        abort(151, (payload_name, payload_sha256, sha256_code))\",\n          \"    extract_tar(payload_name)\",\n          \"    # Change owner & group to be root user for the payload.\",\n          \"    shell_command([\\\"chown\\\", \\\"-R\\\", \\\"0:0\\\", tmp_dir])\",\n          \"except Exception as e:\",\n          \"    error_msg = \\\"Unable to load and extract the content of payload, abort.\\\"\",\n          \"    logger.error(error_msg)\",\n          \"    logger.exception(e)\",\n          \"    abort(152)\",\n          \"' | $PYTHON_CMD\",\n          \"echo '\",\n          \"import os\",\n          \"import shutil\",\n          \"import sys\",\n          \"\",\n          \"tmp_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations/\\\")\",\n          \"reboot_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-194/\\\")\",\n          \"reboot_with_failure_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-195/\\\")\",\n          \"reboot_with_dependency_failure_dir = os.path.abspath(\\\"/var/log/amazon/ssm/patch-baseline-operations-196/\\\")\",\n          \"\",\n          \"# When an install occurs and the instance needs a reboot, the agent restarts our plugin.\",\n          \"# Check if these folders exist to know how to succeed or fail a command after a reboot.\",\n          \"\",\n          \"def check_dir_and_exit(dir, exit_code):\",\n          \"    if os.path.exists(dir):\",\n          \"        shutil.rmtree(dir)\",\n          \"        sys.exit(exit_code)\",\n          \"\",\n          \"check_dir_and_exit(reboot_dir, 0)\",\n          \"check_dir_and_exit(reboot_with_failure_dir, 1)\",\n          \"check_dir_and_exit(reboot_with_dependency_failure_dir, 2)\",\n          \"\",\n          \"os.chdir(tmp_dir)\",\n          \"sys.path.insert(0, tmp_dir)\",\n          \"\",\n          \"import errno\",\n          \"import logging\",\n          \"import stat\",\n          \"import subprocess\",\n          \"import uuid\",\n          \"\",\n          \"\",\n          \"ERROR_CODE_MAP = {\",\n          \"    154: \\\"Unable to create dir: %s\\\",\",\n          \"    156: \\\"Error loading patching payload\\\"\",\n          \"}\",\n          \"REBOOT_CODE_MAP = {\",\n          \"    194: reboot_dir,\",\n          \"    195: reboot_with_failure_dir,\",\n          \"    196: reboot_with_dependency_failure_dir\",\n          \"}\",\n          \"\",\n          \"def create_dir(dir_path):\",\n          \"    dirpath = os.path.abspath(dir_path)\",\n          \"    # the dir should NOT exists, but do the check anyway\",\n          \"    if not os.path.exists(dirpath):\",\n          \"        try:\",\n          \"            os.makedirs(dirpath)\",\n          \"        except OSError as e:  # Guard against race condition\",\n          \"            if e.errno != errno.EEXIST:\",\n          \"                raise e\",\n          \"        except Exception as e:\",\n          \"            logger.error(\\\"Unable to create dir: %s\\\", dirpath)\",\n          \"            logger.exception(e)\",\n          \"            abort(154, (dirpath))\",\n          \"\",\n          \"def remove_dir(dir_path):\",\n          \"    if os.path.exists(dir_path):\",\n          \"        shutil.rmtree(dir_path)\",\n          \"\",\n          \"def exit(code):\",\n          \"    if code in REBOOT_CODE_MAP:\",\n          \"        create_dir(REBOOT_CODE_MAP.get(code))\",\n          \"        # Change code to the reboot code to signal the agent to reboot.\",\n          \"        code = 194\",\n          \"    else:\",\n          \"        # No reboot behavior, remove any possible existing reboot directory\",\n          \"        for dir in REBOOT_CODE_MAP.values():\",\n          \"            remove_dir(dir)\",\n          \"    sys.exit(code)\",\n          \"\",\n          \"\",\n          \"def shell_command(cmd_list):\",\n          \"    with open(os.devnull, \\\"w\\\") as devnull:\",\n          \"        p = subprocess.Popen(cmd_list, stdout=subprocess.PIPE, stderr=devnull)\",\n          \"        (std_out, _) = p.communicate()\",\n          \"        if not type(std_out) == str:\",\n          \"            std_out = std_out.decode(\\\"utf-8\\\")\",\n          \"        return std_out, p.returncode\",\n          \"\",\n          \"def abort(error_code, params = ()):\",\n          \"    if os.path.exists(tmp_dir):\",\n          \"        shutil.rmtree(tmp_dir)\",\n          \"    sys.stderr.write(ERROR_CODE_MAP.get(error_code) % params)\",\n          \"    sys.exit(error_code)\",\n          \"\",\n          \"\",\n          \"# initialize logging\",\n          \"LOGGER_FORMAT = \\\"%(asctime)s %(name)s [%(levelname)s]: %(message)s\\\"\",\n          \"LOGGER_DATEFORMAT = \\\"%m/%d/%Y %X\\\"\",\n          \"LOGGER_LEVEL = logging.INFO\",\n          \"LOGGER_STREAM = sys.stdout\",\n          \"\",\n          \"logging.basicConfig(format=LOGGER_FORMAT, datefmt=LOGGER_DATEFORMAT, level=LOGGER_LEVEL, stream=LOGGER_STREAM)\",\n          \"logger = logging.getLogger()\",\n          \"\",\n          \"# Document parameters.\",\n          \"operation_type = \\\"{{Operation}}\\\"\",\n          \"snapshot_id = \\\"{{SnapshotId}}\\\"\",\n          \"install_override_list = \\\"{{InstallOverrideList}}\\\"\",\n          \"reboot_option = \\\"{{RebootOption}}\\\"\",\n          \"\",\n          \"try:\",\n          \"    import os_selector\",\n          \"    exit(os_selector.execute(snapshot_id, operation_type,install_override_list, reboot_option))\",\n          \"except Exception as e:\",\n          \"    error_code = 156\",\n          \"    if hasattr(e, \\\"error_code\\\") and type(e.error_code) == int:\",\n          \"        error_code = e.error_code;\",\n          \"    logger.exception(\\\"Error loading patching payload\\\")\",\n          \"    abort(error_code)\",\n          \"' | $PYTHON_CMD\",\n          \"\",\n          \"TMP_DIR=/var/log/amazon/ssm/patch-baseline-operations\",\n          \"$PYTHON_CMD $TMP_DIR/scripts/urls.py -d \\\"{{Distro}}\\\" -u \\\"{{PackagesUploadURL}}\\\" -o \\\"{{Operation}}\\\"\",\n          \"rm -rf TMP_DIR\"\n        ]\n      }\n    }\n  ]\n}",
  "CreatedDate": "2020-03-18T09:16:26.526Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Command"
  },
  "DocumentVersion": "5",
  "Name": "arn:aws:ssm:us-west-2:822506164844:document/AP-RunPatchBaseline",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "48f0a999-25ee-40ba-aa48-9f894c8403cd",
    "Metadata": {},
    "ChecksumAlgorithm": 0,
    "ChecksumValidationStatus": 0
  },
  "ContentLength": 20655,
  "HttpStatusCode": 200,
  "LoggedAt": "2023-03-23T07:12:54.0162171+00:00"
}
