{
  "AttachmentsContent": [],
  "Content": "{\n  \"schemaVersion\": \"0.3\",\n  \"description\": \"The AWSSupport-StartEC2RescueWorkflow automation document runs the provided base64 encoded script (Bash or Powershell) on a helper instance created to rescue your instance. The root volume of your instance is attached and mounted to the helper instance, also known as the EC2Rescue instance.\",\n  \"assumeRole\": \"{{ AutomationAssumeRole }}\",\n  \"parameters\": {\n    \"InstanceId\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) ID of your EC2 instance. IMPORTANT: AWS Systems Manager Automation stops this instance. Data stored in instance store volumes will be lost. The public IP address will change if you are not using an Elastic IP.\",\n      \"allowedPattern\": \"^i-[a-z0-9]{8,17}$\"\n    },\n    \"OfflineScript\": {\n      \"type\": \"String\",\n      \"description\": \"(Required) Base64 encoded script to execute against the helper instance. Use Bash if your source instance is Linux, and PowerShell if it is Windows.\",\n      \"allowedPattern\": \"^[a-zA-Z0-9+/]{3,}[=]{0,2}$\"\n    },\n    \"EC2RescueInstanceType\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The EC2 instance type for the EC2Rescue instance.\",\n      \"default\": \"t2.small\",\n      \"allowedValues\": [\n        \"t2.small\",\n        \"t2.medium\",\n        \"t2.large\"\n      ]\n    },\n    \"SubnetId\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The subnet ID for the EC2Rescue instance. By default, the same subnet where the provided instance resides is used. IMPORTANT: If you provide a custom subnet, it must be in the same Availability Zone as InstanceId, and it must allow access to the SSM endpoints.\",\n      \"default\": \"SelectedInstanceSubnet\",\n      \"allowedPattern\": \"^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$\"\n    },\n    \"S3BucketName\": {\n      \"description\": \"(Optional) S3 bucket name in your account where you want to upload the troubleshooting logs. Make sure the bucket policy does not grant unnecessary read/write permissions to parties that do not need access to the collected logs.\",\n      \"allowedPattern\": \"^$|^[_a-zA-Z0-9][-._a-zA-Z0-9]{2,62}$\",\n      \"type\": \"String\",\n      \"default\": \"\"\n    },\n    \"S3Prefix\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) A prefix for the S3 logs.\",\n      \"default\": \"AWSSupport-EC2Rescue\",\n      \"allowedPattern\": \"^[a-zA-Z0-9][-./a-zA-Z0-9]{0,255}$\"\n    },\n    \"AMIPrefix\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) A prefix for the backup AMI name.\",\n      \"default\": \"AWSSupport-EC2Rescue\",\n      \"allowedPattern\": \"[-._a-zA-Z0-9]{3,20}$\"\n    },\n    \"CreatePreEC2RescueBackup\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) Set it to True to create an AMI of InstanceId before executing the script. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.\",\n      \"default\": \"False\",\n      \"allowedValues\": [\n        \"True\",\n        \"False\"\n      ]\n    },\n    \"CreatePostEC2RescueBackup\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) Set it to True to create an AMI of InstanceId after executing the script, before starting it. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.\",\n      \"default\": \"False\",\n      \"allowedValues\": [\n        \"True\",\n        \"False\"\n      ]\n    },\n    \"UniqueId\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) A unique identifier for the workflow.\",\n      \"default\": \"{{ automation:EXECUTION_ID }}\"\n    },\n    \"AutomationAssumeRole\": {\n      \"type\": \"String\",\n      \"description\": \"(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to execute this document.\",\n      \"default\": \"\"\n    }\n  },\n  \"mainSteps\": [\n    {\n      \"name\": \"describeInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"RootDeviceName\",\n          \"Selector\": \"$.Reservations[0].Instances[0].RootDeviceName\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"State\",\n          \"Selector\": \"$.Reservations[0].Instances[0].State.Name\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"SubnetId\",\n          \"Selector\": \"$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"Platform\",\n          \"Selector\": \"$.Reservations[0].Instances[0].Platform\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"AvailabilityZone\",\n          \"Selector\": \"$.Reservations[0].Instances[0].Placement.AvailabilityZone\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"isCritical\": \"true\",\n      \"nextStep\": \"describeInstanceRootVolume\"\n    },\n    {\n      \"name\": \"describeInstanceRootVolume\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"Filters\": [\n          {\n            \"Name\": \"attachment.instance-id\",\n            \"Values\": [\n              \"{{ InstanceId }}\"\n            ]\n          },\n          {\n            \"Name\": \"attachment.device\",\n            \"Values\": [\n              \"{{ describeInstance.RootDeviceName }}\"\n            ]\n          }\n        ]\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"RootDeviceVolumeId\",\n          \"Selector\": \"$.Volumes[0].Attachments[0].VolumeId\",\n          \"Type\": \"String\"\n        },\n        {\n          \"Name\": \"RootDeviceDeleteOnTermination\",\n          \"Selector\": \"$.Volumes[0].Attachments[0].DeleteOnTermination\",\n          \"Type\": \"Boolean\"\n        }\n      ],\n      \"isCritical\": \"true\",\n      \"nextStep\": \"assertInstanceRootVolumeIsEbs\"\n    },\n    {\n      \"name\": \"assertInstanceRootVolumeIsEbs\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeInstances\",\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ],\n        \"PropertySelector\": \"$.Reservations[0].Instances[0].RootDeviceType\",\n        \"DesiredValues\": [\n          \"ebs\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"assertInstanceRootVolumeIsNotEncrypted\"\n    },\n    {\n      \"name\": \"assertInstanceRootVolumeIsNotEncrypted\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"Filters\": [\n          {\n            \"Name\": \"attachment.instance-id\",\n            \"Values\": [\n              \"{{ InstanceId }}\"\n            ]\n          },\n          {\n            \"Name\": \"attachment.device\",\n            \"Values\": [\n              \"{{ describeInstance.RootDeviceName }}\"\n            ]\n          }\n        ],\n        \"PropertySelector\": \"$.Volumes[0].Encrypted\",\n        \"DesiredValues\": [\n          \"False\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"branchOnSubnetId\"\n    },\n    {\n      \"name\": \"branchOnSubnetId\",\n      \"action\": \"aws:branch\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"stageEC2RescueAutomationWithInstanceSubnet\",\n            \"Variable\": \"{{ SubnetId }}\",\n            \"StringEquals\": \"SelectedInstanceSubnet\"\n          },\n          {\n            \"NextStep\": \"stageEC2RescueAutomationWithNewVPC\",\n            \"Variable\": \"{{ SubnetId }}\",\n            \"StringEquals\": \"CreateNewVPC\"\n          }\n        ],\n        \"Default\": \"assertCustomSubnetIsInSameAZAsInstance\"\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"stageEC2RescueAutomationWithInstanceSubnet\",\n      \"action\": \"aws:createStack\",\n      \"onFailure\": \"step:describeCloudFormationErrorFromStackEvents\",\n      \"inputs\": {\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"TemplateURL\": \"https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_vd4d4f8a7e4c82ad44c4fe7a5d0262d451315e6a9.template\",\n        \"Capabilities\": [\n          \"CAPABILITY_NAMED_IAM\"\n        ],\n        \"ClientRequestToken\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"Parameters\": [\n          {\n            \"ParameterKey\": \"AZ\",\n            \"ParameterValue\": \"{{ describeInstance.AvailabilityZone }}\"\n          },\n          {\n            \"ParameterKey\": \"SubnetId\",\n            \"ParameterValue\": \"{{ describeInstance.SubnetId }}\"\n          },\n          {\n            \"ParameterKey\": \"S3BucketName\",\n            \"ParameterValue\": \"{{ S3BucketName }}\"\n          },\n          {\n            \"ParameterKey\": \"S3Prefix\",\n            \"ParameterValue\": \"{{ S3Prefix }}\"\n          },\n          {\n            \"ParameterKey\": \"HelperInstanceType\",\n            \"ParameterValue\": \"{{ EC2RescueInstanceType }}\"\n          },\n          {\n            \"ParameterKey\": \"Platform\",\n            \"ParameterValue\": \"{{ describeInstance.Platform }}\"\n          },\n          {\n            \"ParameterKey\": \"ExecutionId\",\n            \"ParameterValue\": \"{{ UniqueId }}\"\n          }\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"ensureNoConcurrentExecutionsForTheInstance\"\n    },\n    {\n      \"name\": \"stageEC2RescueAutomationWithNewVPC\",\n      \"action\": \"aws:createStack\",\n      \"onFailure\": \"step:describeCloudFormationErrorFromStackEvents\",\n      \"inputs\": {\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"TemplateURL\": \"https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_vd4d4f8a7e4c82ad44c4fe7a5d0262d451315e6a9.template\",\n        \"Capabilities\": [\n          \"CAPABILITY_NAMED_IAM\"\n        ],\n        \"ClientRequestToken\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"Parameters\": [\n          {\n            \"ParameterKey\": \"AZ\",\n            \"ParameterValue\": \"{{ describeInstance.AvailabilityZone }}\"\n          },\n          {\n            \"ParameterKey\": \"SubnetId\",\n            \"ParameterValue\": \"\"\n          },\n          {\n            \"ParameterKey\": \"S3BucketName\",\n            \"ParameterValue\": \"{{ S3BucketName }}\"\n          },\n          {\n            \"ParameterKey\": \"S3Prefix\",\n            \"ParameterValue\": \"{{ S3Prefix }}\"\n          },\n          {\n            \"ParameterKey\": \"HelperInstanceType\",\n            \"ParameterValue\": \"{{ EC2RescueInstanceType }}\"\n          },\n          {\n            \"ParameterKey\": \"Platform\",\n            \"ParameterValue\": \"{{ describeInstance.Platform }}\"\n          },\n          {\n            \"ParameterKey\": \"ExecutionId\",\n            \"ParameterValue\": \"{{ UniqueId }}\"\n          }\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"ensureNoConcurrentExecutionsForTheInstance\"\n    },\n    {\n      \"name\": \"assertCustomSubnetIsInSameAZAsInstance\",\n      \"action\": \"aws:assertAwsResourceProperty\",\n      \"onFailure\": \"Abort\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeSubnets\",\n        \"SubnetIds\": [\n          \"{{ SubnetId }}\"\n        ],\n        \"PropertySelector\": \"$.Subnets[0].AvailabilityZone\",\n        \"DesiredValues\": [\n          \"{{ describeInstance.AvailabilityZone }}\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"stageEC2RescueAutomationWithCustomSubnet\"\n    },\n    {\n      \"name\": \"stageEC2RescueAutomationWithCustomSubnet\",\n      \"action\": \"aws:createStack\",\n      \"onFailure\": \"step:describeCloudFormationErrorFromStackEvents\",\n      \"inputs\": {\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"TemplateURL\": \"https://awssupport-ssm.{{ global:REGION }}.s3.amazonaws.com/AWSSupport-StartEC2RescueWorkflow/CloudFormationTemplates/AWSSupport-EC2Rescue_vd4d4f8a7e4c82ad44c4fe7a5d0262d451315e6a9.template\",\n        \"Capabilities\": [\n          \"CAPABILITY_NAMED_IAM\"\n        ],\n        \"ClientRequestToken\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"Parameters\": [\n          {\n            \"ParameterKey\": \"AZ\",\n            \"ParameterValue\": \"{{ describeInstance.AvailabilityZone }}\"\n          },\n          {\n            \"ParameterKey\": \"SubnetId\",\n            \"ParameterValue\": \"{{ SubnetId }}\"\n          },\n          {\n            \"ParameterKey\": \"S3BucketName\",\n            \"ParameterValue\": \"{{ S3BucketName }}\"\n          },\n          {\n            \"ParameterKey\": \"S3Prefix\",\n            \"ParameterValue\": \"{{ S3Prefix }}\"\n          },\n          {\n            \"ParameterKey\": \"HelperInstanceType\",\n            \"ParameterValue\": \"{{ EC2RescueInstanceType }}\"\n          },\n          {\n            \"ParameterKey\": \"Platform\",\n            \"ParameterValue\": \"{{ describeInstance.Platform }}\"\n          },\n          {\n            \"ParameterKey\": \"ExecutionId\",\n            \"ParameterValue\": \"{{ UniqueId }}\"\n          }\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"ensureNoConcurrentExecutionsForTheInstance\"\n    },\n    {\n      \"name\": \"ensureNoConcurrentExecutionsForTheInstance\",\n      \"action\": \"aws:invokeLambdaFunction\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"inputs\": {\n        \"FunctionName\": \"AWSSupport-EC2Rescue-Check-{{ UniqueId }}\",\n        \"Payload\": \"{\\\"ResourceProperties\\\": {\\\"Region\\\": \\\"{{ global:REGION }}\\\", \\\"InstanceId\\\": \\\"{{ InstanceId }}\\\", \\\"ExecutionId\\\": \\\"{{ automation:EXECUTION_ID }}\\\", \\\"UniqueId\\\": \\\"{{ UniqueId }}\\\" }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"createEC2RescueInstance\"\n    },\n    {\n      \"name\": \"createEC2RescueInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"step:describeCloudFormationErrorFromStackEvents\",\n      \"inputs\": {\n        \"Service\": \"cloudformation\",\n        \"Api\": \"UpdateStack\",\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"UsePreviousTemplate\": true,\n        \"ClientRequestToken\": \"AWSSupport-EC2Rescue-Update-{{ UniqueId }}\",\n        \"Parameters\": [\n          {\n            \"ParameterKey\": \"CreateHelperInstance\",\n            \"ParameterValue\": \"True\"\n          },\n          {\n            \"ParameterKey\": \"AZ\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"SubnetId\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"S3BucketName\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"S3Prefix\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"Platform\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"ExecutionId\",\n            \"UsePreviousValue\": true\n          },\n          {\n            \"ParameterKey\": \"HelperInstanceType\",\n            \"UsePreviousValue\": true\n          }\n        ],\n        \"Capabilities\": [\n          \"CAPABILITY_NAMED_IAM\"\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForEC2RescueInstanceCreation\"\n    },\n    {\n      \"name\": \"waitForEC2RescueInstanceCreation\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"step:describeCloudFormationErrorFromStackEvents\",\n      \"timeoutSeconds\": \"600\",\n      \"inputs\": {\n        \"Service\": \"cloudformation\",\n        \"Api\": \"DescribeStacks\",\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\",\n        \"PropertySelector\": \"$.Stacks[0].StackStatus\",\n        \"DesiredValues\": [\n          \"UPDATE_COMPLETE\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"describeEC2RescueInstance\"\n    },\n    {\n      \"name\": \"describeEC2RescueInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"inputs\": {\n        \"Service\": \"cloudformation\",\n        \"Api\": \"DescribeStacks\",\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"EC2RescueInstanceId\",\n          \"Selector\": \"$.Stacks[0].Outputs[0].OutputValue\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForEC2RescueInstanceToBeManaged\"\n    },\n    {\n      \"name\": \"waitForEC2RescueInstanceToBeManaged\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"step:rebootEC2RescueInstance\",\n      \"timeoutSeconds\": \"600\",\n      \"inputs\": {\n        \"Service\": \"ssm\",\n        \"Api\": \"DescribeInstanceInformation\",\n        \"InstanceInformationFilterList\": [\n          {\n            \"key\": \"InstanceIds\",\n            \"valueSet\": [\n              \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n            ]\n          }\n        ],\n        \"PropertySelector\": \"$.InstanceInformationList[0].PingStatus\",\n        \"DesiredValues\": [\n          \"Online\"\n        ]\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"stopInstance\"\n    },\n    {\n      \"name\": \"rebootEC2RescueInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"RebootInstances\",\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitAgainForEC2RescueInstanceToBeManaged\"\n    },\n    {\n      \"name\": \"waitAgainForEC2RescueInstanceToBeManaged\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"timeoutSeconds\": \"600\",\n      \"inputs\": {\n        \"Service\": \"ssm\",\n        \"Api\": \"DescribeInstanceInformation\",\n        \"InstanceInformationFilterList\": [\n          {\n            \"key\": \"InstanceIds\",\n            \"valueSet\": [\n              \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n            ]\n          }\n        ],\n        \"PropertySelector\": \"$.InstanceInformationList[0].PingStatus\",\n        \"DesiredValues\": [\n          \"Online\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"stopInstance\"\n    },\n    {\n      \"name\": \"stopInstance\",\n      \"action\": \"aws:changeInstanceState\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ],\n        \"CheckStateOnly\": false,\n        \"DesiredState\": \"stopped\"\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"forceStopInstance\"\n    },\n    {\n      \"name\": \"forceStopInstance\",\n      \"action\": \"aws:changeInstanceState\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"inputs\": {\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ],\n        \"CheckStateOnly\": false,\n        \"DesiredState\": \"stopped\",\n        \"Force\": true\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"branchOnPreEC2RescueBackup\"\n    },\n    {\n      \"name\": \"branchOnPreEC2RescueBackup\",\n      \"action\": \"aws:branch\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"preScriptBackup\",\n            \"Variable\": \"{{ CreatePreEC2RescueBackup }}\",\n            \"StringEquals\": \"True\"\n          }\n        ],\n        \"Default\": \"installEC2RescueOnEC2RescueInstance\"\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"preScriptBackup\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"step:unstageEC2RescueAutomation\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"CreateImage\",\n        \"InstanceId\": \"{{ InstanceId }}\",\n        \"Description\": \"Pre-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.\",\n        \"NoReboot\": false,\n        \"Name\": \"{{ AMIPrefix }}-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"ImageId\",\n          \"Selector\": \"$.ImageId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"isCritical\": \"true\",\n      \"nextStep\": \"tagPreScriptBackup\"\n    },\n    {\n      \"name\": \"tagPreScriptBackup\",\n      \"action\": \"aws:createTags\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"ResourceType\": \"EC2\",\n        \"ResourceIds\": [\n          \"{{ preScriptBackup.ImageId }}\"\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"installEC2RescueOnEC2RescueInstance\"\n    },\n    {\n      \"name\": \"installEC2RescueOnEC2RescueInstance\",\n      \"action\": \"aws:runCommand\",\n      \"onFailure\": \"step:restoreInstanceRootVolumeDeleteOnTerminationState\",\n      \"inputs\": {\n        \"DocumentName\": \"AWS-ConfigureAWSPackage\",\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ],\n        \"Parameters\": {\n          \"name\": \"AWSSupport-EC2Rescue\",\n          \"action\": \"Install\",\n          \"version\": \"latest\"\n        }\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"detachInstanceRootVolume\"\n    },\n    {\n      \"name\": \"detachInstanceRootVolume\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DetachVolume\",\n        \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForInstanceRootVolumeToBeDetached\"\n    },\n    {\n      \"name\": \"waitForInstanceRootVolumeToBeDetached\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"VolumeIds\": [\n          \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n        ],\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"available\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"branchOnPlatform\"\n    },\n    {\n      \"name\": \"branchOnPlatform\",\n      \"action\": \"aws:branch\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"attachInstanceRootVolumeToWindowsEC2RescueInstance\",\n            \"Variable\": \"{{ describeInstance.Platform }}\",\n            \"StringEquals\": \"windows\"\n          }\n        ],\n        \"Default\": \"attachInstanceRootVolumeToLinuxEC2RescueInstance\"\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"attachInstanceRootVolumeToWindowsEC2RescueInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"AttachVolume\",\n        \"Device\": \"xvdf\",\n        \"InstanceId\": \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\",\n        \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForInstanceRootVolumeToBeAttachedToWindowsEC2RescueInstance\"\n    },\n    {\n      \"name\": \"waitForInstanceRootVolumeToBeAttachedToWindowsEC2RescueInstance\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"VolumeIds\": [\n          \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n        ],\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"in-use\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitBeforeRunningScriptForWindows\"\n    },\n    {\n      \"name\": \"waitBeforeRunningScriptForWindows\",\n      \"action\": \"aws:sleep\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Duration\": \"PT30S\"\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"runScriptForWindows\"\n    },\n    {\n      \"name\": \"runScriptForWindows\",\n      \"action\": \"aws:runCommand\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"DocumentName\": \"AWS-RunPowerShellScript\",\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ],\n        \"Parameters\": {\n          \"commands\": [\n            \"Import-Module EC2Rescue\",\n            \"\",\n            \"try {\",\n            \"    #region Set volume online and set global variables for the system\",\n            \"    $env:EC2RESCUE_OFFLINE_EBS_DEVICE = \\\"xvdf\\\"\",\n            \"    $env:EC2RESCUE_EC2RW_DIR = \\\"${env:PROGRAMFILES}\\\\Amazon\\\\EC2Rescue\\\"\",\n            \"    $originalDrives = Get-PSDrive -PSProvider FileSystem\",\n            \"    & \\\"${env:EC2RESCUE_EC2RW_DIR}\\\\EC2RescueCmd.exe\\\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only /no-offline /no-fix-signature | Out-Null\",\n            \"    $newDrives = Get-PSDrive -PSProvider FileSystem\",\n            \"    $driveLetters = (Compare-Object $newDrives $originalDrives).InputObject.Name\",\n            \"    if ($driveLetters) {\",\n            \"        Write-Host \\\"Device $env:EC2RESCUE_OFFLINE_EBS_DEVICE mapped to $driveLetters\\\";\",\n            \"        foreach ($driveLetter in $driveLetters) {\",\n            \"            $OfflineWindowsInstall = Get-WindowsInstallData -OfflineWinDrive $driveLetter -IgnoreFailure\",\n            \"            if ($OfflineWindowsInstall) {\",\n            \"                $env:EC2RESCUE_ACCOUNT_ID = \\\"{{ global:ACCOUNT_ID }}\\\"\",\n            \"                $env:EC2RESCUE_DATE = \\\"{{ global:DATE }}\\\"\",\n            \"                $env:EC2RESCUE_DATE_TIME = \\\"{{ global:DATE_TIME }}\\\"\",\n            \"                $env:EC2RESCUE_EXECUTION_ID = \\\"{{ automation:EXECUTION_ID }}\\\"\",\n            \"                $env:EC2RESCUE_OFFLINE_CURRENT_CONTROL_SET = $OfflineWindowsInstall.CurrentControlSet\",\n            \"                $env:EC2RESCUE_OFFLINE_DRIVE = $OfflineWindowsInstall.OfflineWindowsDrive\",\n            \"                #$env:EC2RESCUE_OFFLINE_EBS_DEVICE set earlier in the script\",\n            \"                $env:EC2RESCUE_OFFLINE_KERNEL_VER = $OfflineWindowsInstall.KernelVer\",\n            \"                $env:EC2RESCUE_OFFLINE_OS_ARCHITECTURE = $OfflineWindowsInstall.OSArchitecture\",\n            \"                $env:EC2RESCUE_OFFLINE_OS_TYPE = $OfflineWindowsInstall.OSType\",\n            \"                $env:EC2RESCUE_OFFLINE_OS_CAPTION = $OfflineWindowsInstall.OSCaption\",\n            \"                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_DIR = $OfflineWindowsInstall.ProgramFilesDir\",\n            \"                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_X86_DIR = $OfflineWindowsInstall.ProgramFilesDirx86\",\n            \"                $env:EC2RESCUE_OFFLINE_REGISTRY_DIR = $OfflineWindowsInstall.RegistryDir\",\n            \"                $env:EC2RESCUE_OFFLINE_SYSTEM_ROOT = $OfflineWindowsInstall.SystemRoot\",\n            \"                #$env:EC2RESCUE_PATH already set during package installation\",\n            \"                $env:EC2RESCUE_REGION = \\\"{{ global:REGION }}\\\"\",\n            \"                $env:EC2RESCUE_S3_BUCKET = \\\"{{ S3BucketName }}\\\"\",\n            \"                $env:EC2RESCUE_S3_PREFIX = \\\"{{ S3Prefix }}\\\"\",\n            \"                $env:EC2RESCUE_SOURCE_INSTANCE = \\\"{{ InstanceId }}\\\"\",\n            \"                Write-Host \\\"EC2Rescue environment variables set\\\";\",\n            \"                $script:EC2RESCUE_OFFLINE_WINDOWS_INSTALL = $OfflineWindowsInstall\",\n            \"                Write-Host \\\"EC2Rescue script variables set\\\";\",\n            \"            }                    \",\n            \"        }\",\n            \"    }\",\n            \"    #endregion\",\n            \"    \",\n            \"    #region Execute user-provided script\",\n            \"    $scriptblock = [scriptblock]::Create([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String('{{ OfflineScript }}')))\",\n            \"    & $scriptblock\",\n            \"    #endregion\",\n            \"\",\n            \"    #region Fix disk signature and set volume offline\",\n            \"    & \\\"${env:EC2RESCUE_EC2RW_DIR}\\\\EC2RescueCmd.exe\\\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null\",\n            \"    Write-Host \\\"Volume successfully set offline\\\"\",\n            \"    #endregion\",\n            \"}\",\n            \"catch {\",\n            \"    Write-Host $_.Exception.Message\",\n            \"    #Disk signature fix\",\n            \"    & \\\"${env:EC2RESCUE_EC2RW_DIR}\\\\EC2RescueCmd.exe\\\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null\",\n            \"    exit 1\",\n            \"}\"\n          ]\n        }\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"stopEC2RescueInstance\"\n    },\n    {\n      \"name\": \"attachInstanceRootVolumeToLinuxEC2RescueInstance\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"AttachVolume\",\n        \"Device\": \"/dev/sdf\",\n        \"InstanceId\": \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\",\n        \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForInstanceRootVolumeToBeAttachedToLinuxEC2RescueInstance\"\n    },\n    {\n      \"name\": \"waitForInstanceRootVolumeToBeAttachedToLinuxEC2RescueInstance\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"VolumeIds\": [\n          \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n        ],\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"in-use\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitBeforeRunningScriptForLinux\"\n    },\n    {\n      \"name\": \"waitBeforeRunningScriptForLinux\",\n      \"action\": \"aws:sleep\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Duration\": \"PT30S\"\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"runScriptForLinux\"\n    },\n    {\n      \"name\": \"runScriptForLinux\",\n      \"action\": \"aws:runCommand\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"DocumentName\": \"AWS-RunShellScript\",\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ],\n        \"Parameters\": {\n          \"commands\": [\n            \"#!/bin/sh\",\n            \"# {{ InstanceId }} -> instance to which the rescue volume belongs\",\n            \"# {{ S3BucketName }} -> S3 bucket where the logs should be uploaded\",\n            \"error_trap()\",\n            \"{\",\n            \"    if test -n \\\"$1\\\" ; then\",\n            \"        printf \\\"%s\\\\\\\\n\\\" \\\"$1\\\"\",\n            \"    fi\",\n            \"\",\n            \"    printf \\\"%.s=\\\" $(seq 1 80)\",\n            \"    printf \\\"\\\\\\\\nThe EC2Rescue execution did not complete successfully.\\\\\\\\n\\\"\",\n            \"\",\n            \"    cleanup\",\n            \"\",\n            \"    exit 1\",\n            \"}\",\n            \"\",\n            \"cleanup()\",\n            \"{\",\n            \"    # Recreate the symlink if resolv.conf was one\",\n            \"    if test \\\"${RESOLV_CONF_IS_SYMLINK}\\\" == \\\"True\\\"; then\",\n            \"        cd \\\"${CHROOT}\\\"\",\n            \"        if test -e etc/resolv.conf; then\",\n            \"            rm -v etc/resolv.conf\",\n            \"        fi\",\n            \"        ln -s \\\"${SYMLINK_TARGET}\\\" etc/resolv.conf\",\n            \"        cd - 1>/dev/null\",\n            \"    # Restore original resolv.conf if it was backed up\",\n            \"    elif test -e \\\"${CHROOT}\\\"/etc/resolv.conf.back ; then\",\n            \"        mv -v \\\"${CHROOT}\\\"/etc/resolv.conf.back \\\"${CHROOT}/etc/resolv.conf\\\"\",\n            \"    fi\",\n            \"\",\n            \"    if mount | grep -qc /mnt/mount ; then\",\n            \"        umount -vR \\\"${CHROOT}\\\" 2>&1\",\n            \"    fi\",\n            \"}\",\n            \"export CHROOT=/mnt/mount\",\n            \"unalias -a\",\n            \"\",\n            \"# Check that a compatible Python interpreter is available in the host environemnt\",\n            \"if command -v python3 > /dev/null; then\",\n            \"    PYTHON=python3\",\n            \"elif command -v python2.7 > /dev/null; then\",\n            \"    PYTHON=python2.7\",\n            \"else\",\n            \"    error_trap \\\"Failed to find compatible Python environment!\\\"\",\n            \"fi\",\n            \"\",\n            \"# Find the root file system on the rescue volume\",\n            \"printf \\\"Locating rescue device\\\\\\\\n\\\"\",\n            \"RESCUE_DEVICE=\\\"$(${PYTHON} -c \\\"\",\n            \"from __future__ import print_function\",\n            \"import ctypes\",\n            \"import ctypes.util\",\n            \"import os\",\n            \"import re\",\n            \"import shlex\",\n            \"import subprocess\",\n            \"import sys\",\n            \"\",\n            \"EXPECTED_ROOT_FS_DIRS = {'bin', 'boot', 'dev', 'etc', 'home', 'proc', 'root', 'sbin', 'sys', 'tmp', 'usr', 'var'}\",\n            \"MOUNT_POINT = os.environ['CHROOT']\",\n            \"LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)\",\n            \"\",\n            \"\",\n            \"def contains_root_fs(device_name):\",\n            \"    if not os.path.isdir(MOUNT_POINT):\",\n            \"        os.makedirs(MOUNT_POINT)\",\n            \"    # TODO find a more native way to obtain the filesystem type\",\n            \"    try:\",\n            \"        fs_type = subprocess.check_output(shlex.split('blkid {} -s TYPE -o value'.format(device_name)),\",\n            \"                                          universal_newlines=True).strip()\",\n            \"    except Exception:\",\n            \"        return False\",\n            \"    try:\",\n            \"        # Python does not have a builtin for mount so use libc to do it\",\n            \"        # Ref: https://www.gnu.org/software/libc/manual/html_node/Mount_002dUnmount_002dRemount.html\",\n            \"        # ctypes does not automatically convert unicode/byte strings so it is necessary to encode them in Python 3\",\n            \"        ret = LIBC.mount(device_name.encode('ascii'), MOUNT_POINT.encode('ascii'), fs_type.encode('ascii'), 0, None)\",\n            \"        if ret:\",\n            \"            # the_errno = ctypes.get_errno()\",\n            \"            # print('Failed to mount {}. {}'.format(device_name, os.strerror(the_errno)))\",\n            \"            return False\",\n            \"        if EXPECTED_ROOT_FS_DIRS & set(os.listdir(MOUNT_POINT)) == EXPECTED_ROOT_FS_DIRS:\",\n            \"            return True\",\n            \"        else:\",\n            \"            return False\",\n            \"    finally:\",\n            \"        LIBC.umount(MOUNT_POINT.encode('ascii'))\",\n            \"\",\n            \"\",\n            \"def run():\",\n            \"    # This detection method relies on udev's standard storage naming rules\",\n            \"    # https://cgit.freedesktop.org/systemd/systemd/tree/rules/60-persistent-storage.rules\",\n            \"    partitions = list()\",\n            \"    device_mapping = dict()\",\n            \"    root_fs_dev = ''\",\n            \"    possible_rescue_vol_root_fs_dev = list()\",\n            \"    part_regex = re.compile(r'^.*part\\\\d*$')\",\n            \"\",\n            \"    os.chdir('/dev/disk/by-path/')\",\n            \"    for device_path in os.listdir('/dev/disk/by-path'):\",\n            \"        device_abs_path = os.path.join(os.path.abspath(os.readlink(device_path)))\",\n            \"        if re.match(part_regex, device_path):\",\n            \"            partitions.append(device_abs_path)\",\n            \"        else:\",\n            \"            device_mapping[device_abs_path] = list()\",\n            \"    for device_name in device_mapping.keys():\",\n            \"        for partition_name in partitions:\",\n            \"            if device_name in partition_name:\",\n            \"                device_mapping[device_name].append(partition_name)\",\n            \"\",\n            \"    with open('/proc/mounts') as proc_mounts:\",\n            \"        for mount in proc_mounts:\",\n            \"            mount = mount.split()\",\n            \"            if mount[1] == '/':\",\n            \"                root_fs_dev = mount[0]\",\n            \"                break\",\n            \"    if not root_fs_dev:\",\n            \"        return 'Error: failed to find device name of root volume.'\",\n            \"\",\n            \"    for block_dev_name in device_mapping.keys():\",\n            \"        # If the root device is a disk\",\n            \"        if block_dev_name == root_fs_dev:\",\n            \"            break\",\n            \"        # If the root device is a partition\",\n            \"        else:\",\n            \"            if root_fs_dev in device_mapping[block_dev_name]:\",\n            \"                root_fs_dev = block_dev_name\",\n            \"                break\",\n            \"    del device_mapping[root_fs_dev]\",\n            \"    if not device_mapping:\",\n            \"        return 'Error: no rescue volume attached.'\",\n            \"\",\n            \"    for possible_rescue_vol_dev in device_mapping.keys():\",\n            \"        # Volume does not use partitions\",\n            \"        if len(device_mapping[possible_rescue_vol_dev]) == 0:\",\n            \"            if contains_root_fs(possible_rescue_vol_dev):\",\n            \"                possible_rescue_vol_root_fs_dev.append(possible_rescue_vol_dev)\",\n            \"        # Volume contains one or more partitions\",\n            \"        else:\",\n            \"            for partition_name in device_mapping[possible_rescue_vol_dev]:\",\n            \"                if contains_root_fs(partition_name):\",\n            \"                    possible_rescue_vol_root_fs_dev.append(partition_name)\",\n            \"\",\n            \"    if len(possible_rescue_vol_root_fs_dev) == 1:\",\n            \"        print(possible_rescue_vol_root_fs_dev[0])\",\n            \"    elif len(possible_rescue_vol_root_fs_dev) > 1:\",\n            \"        return 'Error: found more than one possible rescue volume with a root filesystem: {}'.format(\",\n            \"            ', '.join(possible_rescue_vol_root_fs_dev))\",\n            \"    else:\",\n            \"        return 'Error: failed to find a rescue volume with a root filesystem.'\",\n            \"\",\n            \"\",\n            \"if __name__ == '__main__':\",\n            \"    sys.exit(run())\",\n            \"\\\")\\\" || error_trap\",\n            \"\",\n            \"# Unlabel the rescue instance's root volume to prevent false positive detection of duplicate labels\",\n            \"e2label /dev/xvda1 \\\"\\\" || error_trap \\\"Failed to unlabel the rescue instance's root volume\\\"\",\n            \"sed -i \\\"s|LABEL=/|UUID=$(blkid /dev/xvda1 -s UUID -o value)|\\\" /etc/fstab || error_trap \\\"Failed to update /etc/fstab on rescue instance\\\"\",\n            \"\",\n            \"# Prepare for chroot\",\n            \"printf \\\"Mounting rescue volume %s\\\\\\\\n\\\" \\\"${RESCUE_DEVICE}\\\" || error_trap\",\n            \"mount \\\"${RESCUE_DEVICE}\\\" \\\"${CHROOT}\\\" || error_trap\",\n            \"mount -R /sys \\\"${CHROOT}\\\"/sys || error_trap\",\n            \"mount --make-rslave \\\"${CHROOT}\\\"/sys || error_trap\",\n            \"mount -R /dev \\\"${CHROOT}\\\"/dev || error_trap\",\n            \"mount --make-rslave \\\"${CHROOT}\\\"/dev || error_trap\",\n            \"mount -t proc /proc \\\"${CHROOT}\\\"/proc || error_trap\",\n            \"\",\n            \"RESOLV_CONF_IS_SYMLINK=False\",\n            \"SYMLINK_TARGET=\\\"\\\"\",\n            \"# /etc/resolv.conf is a symlink in Ubuntu so dereference the symlink if needed\",\n            \"if test -h \\\"${CHROOT}/etc/resolv.conf\\\"; then\",\n            \"    RESOLV_CONF_IS_SYMLINK=True\",\n            \"    SYMLINK_TARGET=$(readlink \\\"${CHROOT}/etc/resolv.conf\\\")\",\n            \"    unlink \\\"${CHROOT}/etc/resolv.conf\\\"\",\n            \"    printf \\\"unlink %s\\\\\\\\n\\\" \\\"${CHROOT}/etc/resolv.conf\\\"\",\n            \"elif test -e \\\"${CHROOT}/etc/resolv.conf\\\" ; then\",\n            \"    cp -v \\\"${CHROOT}/etc/resolv.conf\\\" \\\"${CHROOT}\\\"/etc/resolv.conf.back || error_trap\",\n            \"fi\",\n            \"cp -v /etc/resolv.conf \\\"${CHROOT}/etc/resolv.conf\\\" || error_trap\",\n            \"\",\n            \"# Copy ec2rl from the rescue host to the rescue slave/volume\",\n            \"# This may \\\"upgrade\\\" the version on the rescue volume if it was already installed\",\n            \"EC2RL_DIR=\\\"$(dirname \\\"$(readlink /usr/bin/ec2rl)\\\")\\\"\",\n            \"mkdir -vp \\\"$(dirname \\\"${CHROOT}\\\"\\\"${EC2RL_DIR}\\\")\\\" || error_trap\",\n            \"cp -r \\\"${EC2RL_DIR}\\\" \\\"${CHROOT}\\\"\\\"$(dirname ${EC2RL_DIR})\\\" || error_trap \\\"Failed to copy ec2rl to rescue volume\\\"\",\n            \"\",\n            \"mkdir -vp \\\"${CHROOT}\\\"/usr/bin || error_trap \\\"Failed to create ${CHROOT}/usr/bin\\\"\",\n            \"\",\n            \"rm -v \\\"${CHROOT}\\\"/usr/bin/ec2rl\",\n            \"ln -vs \\\"${EC2RL_DIR}\\\"/ec2rl \\\"${CHROOT}\\\"/usr/bin/ec2rl || error_trap \\\"Failed to create ec2rl symlink\\\"\",\n            \"\",\n            \"export EC2RESCUE_ACCOUNT_ID=\\\"{{ global:ACCOUNT_ID }}\\\"\",\n            \"export EC2RESCUE_DATE=\\\"{{ global:DATE }}\\\"\",\n            \"export EC2RESCUE_DATE_TIME=\\\"{{ global:DATE_TIME }}\\\"\",\n            \"export EC2RESCUE_REGION=\\\"{{ global:REGION }}\\\"\",\n            \"export EC2RESCUE_EXECUTION_ID=\\\"{{ automation:EXECUTION_ID }}\\\"\",\n            \"export EC2RESCUE_SOURCE_INSTANCE=\\\"{{ InstanceId }}\\\"\",\n            \"export EC2RESCUE_S3_BUCKET=\\\"{{ S3BucketName }}\\\"\",\n            \"export EC2RESCUE_S3_PREFIX=\\\"{{ S3Prefix }}\\\"\",\n            \"export EC2RESCUE_OFFLINE_EBS_DEVICE=\\\"/dev/sdf\\\"\",\n            \"export EC2RESCUE_OFFLINE_DEVICE=$RESCUE_DEVICE\",\n            \"export EC2RESCUE_OFFLINE_SYSTEM_ROOT=$CHROOT\",\n            \"export EC2RESCUE_PYTHON=$PYTHON\",\n            \"export EC2RESCUE_EC2RL_DIR=$EC2RL_DIR\",\n            \"\",\n            \"base64 -d <<< {{ OfflineScript }} | /bin/bash \",\n            \"\",\n            \"cleanup\"\n          ]\n        }\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"stopEC2RescueInstance\"\n    },\n    {\n      \"name\": \"stopEC2RescueInstance\",\n      \"action\": \"aws:changeInstanceState\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ],\n        \"CheckStateOnly\": false,\n        \"DesiredState\": \"stopped\"\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"forceStopEC2RescueInstance\"\n    },\n    {\n      \"name\": \"forceStopEC2RescueInstance\",\n      \"action\": \"aws:changeInstanceState\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"InstanceIds\": [\n          \"{{ describeEC2RescueInstance.EC2RescueInstanceId }}\"\n        ],\n        \"CheckStateOnly\": false,\n        \"DesiredState\": \"stopped\",\n        \"Force\": true\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"detachInstanceRootVolumeFromEC2RescueInstance\"\n    },\n    {\n      \"name\": \"detachInstanceRootVolumeFromEC2RescueInstance\",\n      \"onFailure\": \"Continue\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DetachVolume\",\n        \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForRescuedInstanceRootVolumeToBeDetached\"\n    },\n    {\n      \"name\": \"waitForRescuedInstanceRootVolumeToBeDetached\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"VolumeIds\": [\n          \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n        ],\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"available\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"attachInstanceRootVolumeToInstance\"\n    },\n    {\n      \"name\": \"attachInstanceRootVolumeToInstance\",\n      \"onFailure\": \"Continue\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"AttachVolume\",\n        \"Device\": \"{{ describeInstance.RootDeviceName }}\",\n        \"InstanceId\": \"{{ InstanceId }}\",\n        \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"waitForRescuedInstanceRootVolumeToBeAttached\"\n    },\n    {\n      \"name\": \"waitForRescuedInstanceRootVolumeToBeAttached\",\n      \"action\": \"aws:waitForAwsResourceProperty\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"DescribeVolumes\",\n        \"VolumeIds\": [\n          \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n        ],\n        \"PropertySelector\": \"$.Volumes[0].State\",\n        \"DesiredValues\": [\n          \"in-use\"\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"branchOnPostEC2RescueBackup\"\n    },\n    {\n      \"name\": \"branchOnPostEC2RescueBackup\",\n      \"action\": \"aws:branch\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Choices\": [\n          {\n            \"NextStep\": \"postScriptBackup\",\n            \"Variable\": \"{{ CreatePostEC2RescueBackup }}\",\n            \"StringEquals\": \"True\"\n          }\n        ],\n        \"Default\": \"restoreInstanceRootVolumeDeleteOnTerminationState\"\n      },\n      \"isCritical\": \"true\"\n    },\n    {\n      \"name\": \"postScriptBackup\",\n      \"action\": \"aws:executeAwsApi\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"CreateImage\",\n        \"InstanceId\": \"{{ InstanceId }}\",\n        \"Description\": \"Post-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.\",\n        \"NoReboot\": false,\n        \"Name\": \"{{ AMIPrefix }}-Post-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"ImageId\",\n          \"Selector\": \"$.ImageId\",\n          \"Type\": \"String\"\n        }\n      ],\n      \"isCritical\": \"true\",\n      \"nextStep\": \"tagPostScriptBackup\"\n    },\n    {\n      \"name\": \"tagPostScriptBackup\",\n      \"action\": \"aws:createTags\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"ResourceType\": \"EC2\",\n        \"ResourceIds\": [\n          \"{{ postScriptBackup.ImageId }}\"\n        ],\n        \"Tags\": [\n          {\n            \"Key\": \"Name\",\n            \"Value\": \"AWSSupport-EC2Rescue: {{ InstanceId }}\"\n          },\n          {\n            \"Key\": \"AWSSupport-EC2Rescue-AutomationExecution\",\n            \"Value\": \"{{ UniqueId }}\"\n          }\n        ]\n      },\n      \"isCritical\": \"false\",\n      \"nextStep\": \"restoreInstanceRootVolumeDeleteOnTerminationState\"\n    },\n    {\n      \"name\": \"restoreInstanceRootVolumeDeleteOnTerminationState\",\n      \"onFailure\": \"Continue\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"ec2\",\n        \"Api\": \"ModifyInstanceAttribute\",\n        \"InstanceId\": \"{{ InstanceId }}\",\n        \"BlockDeviceMappings\": [\n          {\n            \"DeviceName\": \"{{ describeInstance.RootDeviceName }}\",\n            \"Ebs\": {\n              \"DeleteOnTermination\": \"{{ describeInstanceRootVolume.RootDeviceDeleteOnTermination }}\",\n              \"VolumeId\": \"{{ describeInstanceRootVolume.RootDeviceVolumeId }}\"\n            }\n          }\n        ]\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"restoreInstanceInitialState\"\n    },\n    {\n      \"name\": \"restoreInstanceInitialState\",\n      \"action\": \"aws:changeInstanceState\",\n      \"onFailure\": \"Continue\",\n      \"inputs\": {\n        \"InstanceIds\": [\n          \"{{ InstanceId }}\"\n        ],\n        \"DesiredState\": \"{{ describeInstance.State }}\"\n      },\n      \"isCritical\": \"true\",\n      \"nextStep\": \"unstageEC2RescueAutomation\"\n    },\n    {\n      \"name\": \"describeCloudFormationErrorFromStackEvents\",\n      \"onFailure\": \"Continue\",\n      \"action\": \"aws:executeAwsApi\",\n      \"inputs\": {\n        \"Service\": \"cloudformation\",\n        \"Api\": \"DescribeStackEvents\",\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\"\n      },\n      \"outputs\": [\n        {\n          \"Name\": \"Events\",\n          \"Selector\": \"$.StackEvents..ResourceStatusReason\",\n          \"Type\": \"StringList\"\n        }\n      ],\n      \"isCritical\": \"false\",\n      \"nextStep\": \"unstageEC2RescueAutomation\"\n    },\n    {\n      \"name\": \"unstageEC2RescueAutomation\",\n      \"action\": \"aws:deleteStack\",\n      \"maxAttempts\": 3,\n      \"inputs\": {\n        \"StackName\": \"AWSSupport-EC2Rescue-{{ UniqueId }}\"\n      },\n      \"isCritical\": \"true\",\n      \"isEnd\": \"true\"\n    }\n  ],\n  \"outputs\": [\n    \"runScriptForLinux.Output\",\n    \"runScriptForWindows.Output\",\n    \"preScriptBackup.ImageId\",\n    \"postScriptBackup.ImageId\"\n  ]\n}",
  "CreatedDate": "2021-11-12T04:15:38.475Z",
  "DisplayName": null,
  "DocumentFormat": {
    "Value": "JSON"
  },
  "DocumentType": {
    "Value": "Automation"
  },
  "DocumentVersion": "13",
  "Name": "AWSSupport-StartEC2RescueWorkflow",
  "Requires": [],
  "ReviewStatus": null,
  "Status": {
    "Value": "Active"
  },
  "StatusInformation": null,
  "VersionName": null,
  "ResponseMetadata": {
    "RequestId": "ea24ff76-2a4d-4ec7-a01c-6c3be96d2c89",
    "Metadata": {}
  },
  "ContentLength": 54359,
  "HttpStatusCode": 200,
  "LoggedAt": "2022-01-26T07:10:56.3969391+00:00"
}
